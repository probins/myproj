{"version":3,"file":"index-47a7fca3.js","sources":["../../../proj4js/lib/constants/values.js","../../../proj4js/lib/constants/PrimeMeridian.js","../../../proj4js/lib/constants/units.js","../../../proj4js/lib/match.js","../../../proj4js/lib/projString.js","../../../proj4js/node_modules/wkt-parser/parser.js","../../../proj4js/node_modules/wkt-parser/process.js","../../../proj4js/node_modules/wkt-parser/index.js","../../../proj4js/lib/defs.js","../../../proj4js/lib/global.js","../../../proj4js/lib/parseCode.js","../../../proj4js/lib/extend.js","../../../proj4js/lib/projections/longlat.js","../../../proj4js/lib/projections.js","../../../proj4js/lib/constants/Ellipsoid.js","../../../proj4js/lib/constants/Datum.js","../../../proj4js/lib/Proj.js","../../../proj4js/lib/deriveConstants.js","../../../proj4js/lib/datum.js","../../../proj4js/lib/datum_transform.js","../../../proj4js/lib/datumUtils.js","../../../proj4js/lib/adjust_axis.js","../../../proj4js/lib/common/toPoint.js","../../../proj4js/lib/checkSanity.js","../../../proj4js/lib/transform.js","../../../proj4js/lib/core.js","../../../proj4js/node_modules/mgrs/mgrs.js","../../../proj4js/lib/Point.js","../../../proj4js/lib/index.js"],"sourcesContent":["export var PJD_3PARAM = 1;\nexport var PJD_7PARAM = 2;\nexport var PJD_WGS84 = 4; // WGS84 or equivalent\nexport var PJD_NODATUM = 5; // WGS84 or equivalent\nexport var SEC_TO_RAD = 4.84813681109535993589914102357e-6;\nexport var HALF_PI = Math.PI/2;\n// ellipoid pj_set_ell.c\nexport var SIXTH = 0.1666666666666666667;\n/* 1/6 */\nexport var RA4 = 0.04722222222222222222;\n/* 17/360 */\nexport var RA6 = 0.02215608465608465608;\nexport var EPSLN = 1.0e-10;\n// you'd think you could use Number.EPSILON above but that makes\n// Mollweide get into an infinate loop.\n\nexport var D2R = 0.01745329251994329577;\nexport var R2D = 57.29577951308232088;\nexport var FORTPI = Math.PI/4;\nexport var TWO_PI = Math.PI * 2;\n// SPI is slightly greater than Math.PI, so values that exceed the -180..180\n// degree range by a tiny amount don't get wrapped. This prevents points that\n// have drifted from their original location along the 180th meridian (due to\n// floating point error) from changing their sign.\nexport var SPI = 3.14159265359;\n","var exports = {};\nexport {exports as default};\n\nexports.greenwich = 0.0; //\"0dE\",\nexports.lisbon = -9.131906111111; //\"9d07'54.862\\\"W\",\nexports.paris = 2.337229166667; //\"2d20'14.025\\\"E\",\nexports.bogota = -74.080916666667; //\"74d04'51.3\\\"W\",\nexports.madrid = -3.687938888889; //\"3d41'16.58\\\"W\",\nexports.rome = 12.452333333333; //\"12d27'8.4\\\"E\",\nexports.bern = 7.439583333333; //\"7d26'22.5\\\"E\",\nexports.jakarta = 106.807719444444; //\"106d48'27.79\\\"E\",\nexports.ferro = -17.666666666667; //\"17d40'W\",\nexports.brussels = 4.367975; //\"4d22'4.71\\\"E\",\nexports.stockholm = 18.058277777778; //\"18d3'29.8\\\"E\",\nexports.athens = 23.7163375; //\"23d42'58.815\\\"E\",\nexports.oslo = 10.722916666667; //\"10d43'22.5\\\"E\"\n","export default {\n  ft: {to_meter: 0.3048},\n  'us-ft': {to_meter: 1200 / 3937}\n};\n","var ignoredChar = /[\\s_\\-\\/\\(\\)]/g;\nexport default function match(obj, key) {\n  if (obj[key]) {\n    return obj[key];\n  }\n  var keys = Object.keys(obj);\n  var lkey = key.toLowerCase().replace(ignoredChar, '');\n  var i = -1;\n  var testkey, processedKey;\n  while (++i < keys.length) {\n    testkey = keys[i];\n    processedKey = testkey.toLowerCase().replace(ignoredChar, '');\n    if (processedKey === lkey) {\n      return obj[testkey];\n    }\n  }\n}\n","import {D2R} from './constants/values';\nimport PrimeMeridian from './constants/PrimeMeridian';\nimport units from './constants/units';\nimport match from './match';\n\nexport default function(defData) {\n  var self = {};\n  var paramObj = defData.split('+').map(function(v) {\n    return v.trim();\n  }).filter(function(a) {\n    return a;\n  }).reduce(function(p, a) {\n    var split = a.split('=');\n    split.push(true);\n    p[split[0].toLowerCase()] = split[1];\n    return p;\n  }, {});\n  var paramName, paramVal, paramOutname;\n  var params = {\n    proj: 'projName',\n    datum: 'datumCode',\n    rf: function(v) {\n      self.rf = parseFloat(v);\n    },\n    lat_0: function(v) {\n      self.lat0 = v * D2R;\n    },\n    lat_1: function(v) {\n      self.lat1 = v * D2R;\n    },\n    lat_2: function(v) {\n      self.lat2 = v * D2R;\n    },\n    lat_ts: function(v) {\n      self.lat_ts = v * D2R;\n    },\n    lon_0: function(v) {\n      self.long0 = v * D2R;\n    },\n    lon_1: function(v) {\n      self.long1 = v * D2R;\n    },\n    lon_2: function(v) {\n      self.long2 = v * D2R;\n    },\n    alpha: function(v) {\n      self.alpha = parseFloat(v) * D2R;\n    },\n    lonc: function(v) {\n      self.longc = v * D2R;\n    },\n    x_0: function(v) {\n      self.x0 = parseFloat(v);\n    },\n    y_0: function(v) {\n      self.y0 = parseFloat(v);\n    },\n    k_0: function(v) {\n      self.k0 = parseFloat(v);\n    },\n    k: function(v) {\n      self.k0 = parseFloat(v);\n    },\n    a: function(v) {\n      self.a = parseFloat(v);\n    },\n    b: function(v) {\n      self.b = parseFloat(v);\n    },\n    r_a: function() {\n      self.R_A = true;\n    },\n    zone: function(v) {\n      self.zone = parseInt(v, 10);\n    },\n    south: function() {\n      self.utmSouth = true;\n    },\n    towgs84: function(v) {\n      self.datum_params = v.split(\",\").map(function(a) {\n        return parseFloat(a);\n      });\n    },\n    to_meter: function(v) {\n      self.to_meter = parseFloat(v);\n    },\n    units: function(v) {\n      self.units = v;\n      var unit = match(units, v);\n      if (unit) {\n        self.to_meter = unit.to_meter;\n      }\n    },\n    from_greenwich: function(v) {\n      self.from_greenwich = v * D2R;\n    },\n    pm: function(v) {\n      var pm = match(PrimeMeridian, v);\n      self.from_greenwich = (pm ? pm : parseFloat(v)) * D2R;\n    },\n    nadgrids: function(v) {\n      if (v === '@null') {\n        self.datumCode = 'none';\n      }\n      else {\n        self.nadgrids = v;\n      }\n    },\n    axis: function(v) {\n      var legalAxis = \"ewnsud\";\n      if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {\n        self.axis = v;\n      }\n    }\n  };\n  for (paramName in paramObj) {\n    paramVal = paramObj[paramName];\n    if (paramName in params) {\n      paramOutname = params[paramName];\n      if (typeof paramOutname === 'function') {\n        paramOutname(paramVal);\n      }\n      else {\n        self[paramOutname] = paramVal;\n      }\n    }\n    else {\n      self[paramName] = paramVal;\n    }\n  }\n  if(typeof self.datumCode === 'string' && self.datumCode !== \"WGS84\"){\n    self.datumCode = self.datumCode.toLowerCase();\n  }\n  return self;\n}\n","export default parseString;\n\nvar NEUTRAL = 1;\nvar KEYWORD = 2;\nvar NUMBER = 3;\nvar QUOTED = 4;\nvar AFTERQUOTE = 5;\nvar ENDED = -1;\nvar whitespace = /\\s/;\nvar latin = /[A-Za-z]/;\nvar keyword = /[A-Za-z84]/;\nvar endThings = /[,\\]]/;\nvar digets = /[\\d\\.E\\-\\+]/;\n// const ignoredChar = /[\\s_\\-\\/\\(\\)]/g;\nfunction Parser(text) {\n  if (typeof text !== 'string') {\n    throw new Error('not a string');\n  }\n  this.text = text.trim();\n  this.level = 0;\n  this.place = 0;\n  this.root = null;\n  this.stack = [];\n  this.currentObject = null;\n  this.state = NEUTRAL;\n}\nParser.prototype.readCharicter = function() {\n  var char = this.text[this.place++];\n  if (this.state !== QUOTED) {\n    while (whitespace.test(char)) {\n      if (this.place >= this.text.length) {\n        return;\n      }\n      char = this.text[this.place++];\n    }\n  }\n  switch (this.state) {\n    case NEUTRAL:\n      return this.neutral(char);\n    case KEYWORD:\n      return this.keyword(char)\n    case QUOTED:\n      return this.quoted(char);\n    case AFTERQUOTE:\n      return this.afterquote(char);\n    case NUMBER:\n      return this.number(char);\n    case ENDED:\n      return;\n  }\n};\nParser.prototype.afterquote = function(char) {\n  if (char === '\"') {\n    this.word += '\"';\n    this.state = QUOTED;\n    return;\n  }\n  if (endThings.test(char)) {\n    this.word = this.word.trim();\n    this.afterItem(char);\n    return;\n  }\n  throw new Error('havn\\'t handled \"' +char + '\" in afterquote yet, index ' + this.place);\n};\nParser.prototype.afterItem = function(char) {\n  if (char === ',') {\n    if (this.word !== null) {\n      this.currentObject.push(this.word);\n    }\n    this.word = null;\n    this.state = NEUTRAL;\n    return;\n  }\n  if (char === ']') {\n    this.level--;\n    if (this.word !== null) {\n      this.currentObject.push(this.word);\n      this.word = null;\n    }\n    this.state = NEUTRAL;\n    this.currentObject = this.stack.pop();\n    if (!this.currentObject) {\n      this.state = ENDED;\n    }\n\n    return;\n  }\n};\nParser.prototype.number = function(char) {\n  if (digets.test(char)) {\n    this.word += char;\n    return;\n  }\n  if (endThings.test(char)) {\n    this.word = parseFloat(this.word);\n    this.afterItem(char);\n    return;\n  }\n  throw new Error('havn\\'t handled \"' +char + '\" in number yet, index ' + this.place);\n};\nParser.prototype.quoted = function(char) {\n  if (char === '\"') {\n    this.state = AFTERQUOTE;\n    return;\n  }\n  this.word += char;\n  return;\n};\nParser.prototype.keyword = function(char) {\n  if (keyword.test(char)) {\n    this.word += char;\n    return;\n  }\n  if (char === '[') {\n    var newObjects = [];\n    newObjects.push(this.word);\n    this.level++;\n    if (this.root === null) {\n      this.root = newObjects;\n    } else {\n      this.currentObject.push(newObjects);\n    }\n    this.stack.push(this.currentObject);\n    this.currentObject = newObjects;\n    this.state = NEUTRAL;\n    return;\n  }\n  if (endThings.test(char)) {\n    this.afterItem(char);\n    return;\n  }\n  throw new Error('havn\\'t handled \"' +char + '\" in keyword yet, index ' + this.place);\n};\nParser.prototype.neutral = function(char) {\n  if (latin.test(char)) {\n    this.word = char;\n    this.state = KEYWORD;\n    return;\n  }\n  if (char === '\"') {\n    this.word = '';\n    this.state = QUOTED;\n    return;\n  }\n  if (digets.test(char)) {\n    this.word = char;\n    this.state = NUMBER;\n    return;\n  }\n  if (endThings.test(char)) {\n    this.afterItem(char);\n    return;\n  }\n  throw new Error('havn\\'t handled \"' +char + '\" in neutral yet, index ' + this.place);\n};\nParser.prototype.output = function() {\n  while (this.place < this.text.length) {\n    this.readCharicter();\n  }\n  if (this.state === ENDED) {\n    return this.root;\n  }\n  throw new Error('unable to parse string \"' +this.text + '\". State is ' + this.state);\n};\n\nfunction parseString(txt) {\n  var parser = new Parser(txt);\n  return parser.output();\n}\n","\n\nfunction mapit(obj, key, value) {\n  if (Array.isArray(key)) {\n    value.unshift(key);\n    key = null;\n  }\n  var thing = key ? {} : obj;\n\n  var out = value.reduce(function(newObj, item) {\n    sExpr(item, newObj);\n    return newObj\n  }, thing);\n  if (key) {\n    obj[key] = out;\n  }\n}\n\nexport function sExpr(v, obj) {\n  if (!Array.isArray(v)) {\n    obj[v] = true;\n    return;\n  }\n  var key = v.shift();\n  if (key === 'PARAMETER') {\n    key = v.shift();\n  }\n  if (v.length === 1) {\n    if (Array.isArray(v[0])) {\n      obj[key] = {};\n      sExpr(v[0], obj[key]);\n      return;\n    }\n    obj[key] = v[0];\n    return;\n  }\n  if (!v.length) {\n    obj[key] = true;\n    return;\n  }\n  if (key === 'TOWGS84') {\n    obj[key] = v;\n    return;\n  }\n  if (key === 'AXIS') {\n    if (!(key in obj)) {\n      obj[key] = [];\n    }\n    obj[key].push(v);\n    return;\n  }\n  if (!Array.isArray(key)) {\n    obj[key] = {};\n  }\n\n  var i;\n  switch (key) {\n    case 'UNIT':\n    case 'PRIMEM':\n    case 'VERT_DATUM':\n      obj[key] = {\n        name: v[0].toLowerCase(),\n        convert: v[1]\n      };\n      if (v.length === 3) {\n        sExpr(v[2], obj[key]);\n      }\n      return;\n    case 'SPHEROID':\n    case 'ELLIPSOID':\n      obj[key] = {\n        name: v[0],\n        a: v[1],\n        rf: v[2]\n      };\n      if (v.length === 4) {\n        sExpr(v[3], obj[key]);\n      }\n      return;\n    case 'PROJECTEDCRS':\n    case 'PROJCRS':\n    case 'GEOGCS':\n    case 'GEOCCS':\n    case 'PROJCS':\n    case 'LOCAL_CS':\n    case 'GEODCRS':\n    case 'GEODETICCRS':\n    case 'GEODETICDATUM':\n    case 'EDATUM':\n    case 'ENGINEERINGDATUM':\n    case 'VERT_CS':\n    case 'VERTCRS':\n    case 'VERTICALCRS':\n    case 'COMPD_CS':\n    case 'COMPOUNDCRS':\n    case 'ENGINEERINGCRS':\n    case 'ENGCRS':\n    case 'FITTED_CS':\n    case 'LOCAL_DATUM':\n    case 'DATUM':\n      v[0] = ['name', v[0]];\n      mapit(obj, key, v);\n      return;\n    default:\n      i = -1;\n      while (++i < v.length) {\n        if (!Array.isArray(v[i])) {\n          return sExpr(v, obj[key]);\n        }\n      }\n      return mapit(obj, key, v);\n  }\n}\n","var D2R = 0.01745329251994329577;\nimport parser from './parser';\nimport {sExpr} from './process';\n\n\n\nfunction rename(obj, params) {\n  var outName = params[0];\n  var inName = params[1];\n  if (!(outName in obj) && (inName in obj)) {\n    obj[outName] = obj[inName];\n    if (params.length === 3) {\n      obj[outName] = params[2](obj[outName]);\n    }\n  }\n}\n\nfunction d2r(input) {\n  return input * D2R;\n}\n\nfunction cleanWKT(wkt) {\n  if (wkt.type === 'GEOGCS') {\n    wkt.projName = 'longlat';\n  } else if (wkt.type === 'LOCAL_CS') {\n    wkt.projName = 'identity';\n    wkt.local = true;\n  } else {\n    if (typeof wkt.PROJECTION === 'object') {\n      wkt.projName = Object.keys(wkt.PROJECTION)[0];\n    } else {\n      wkt.projName = wkt.PROJECTION;\n    }\n  }\n  if (wkt.AXIS) {\n    var axisOrder = '';\n    for (var i = 0, ii = wkt.AXIS.length; i < ii; ++i) {\n      var axis = wkt.AXIS[i];\n      var descriptor = axis[0].toLowerCase();\n      if (descriptor.indexOf('north') !== -1) {\n        axisOrder += 'n';\n      } else if (descriptor.indexOf('south') !== -1) {\n        axisOrder += 's';\n      } else if (descriptor.indexOf('east') !== -1) {\n        axisOrder += 'e';\n      } else if (descriptor.indexOf('west') !== -1) {\n        axisOrder += 'w';\n      }\n    }\n    if (axisOrder.length === 2) {\n      axisOrder += 'u';\n    }\n    if (axisOrder.length === 3) {\n      wkt.axis = axisOrder;\n    }\n  }\n  if (wkt.UNIT) {\n    wkt.units = wkt.UNIT.name.toLowerCase();\n    if (wkt.units === 'metre') {\n      wkt.units = 'meter';\n    }\n    if (wkt.UNIT.convert) {\n      if (wkt.type === 'GEOGCS') {\n        if (wkt.DATUM && wkt.DATUM.SPHEROID) {\n          wkt.to_meter = wkt.UNIT.convert*wkt.DATUM.SPHEROID.a;\n        }\n      } else {\n        wkt.to_meter = wkt.UNIT.convert;\n      }\n    }\n  }\n  var geogcs = wkt.GEOGCS;\n  if (wkt.type === 'GEOGCS') {\n    geogcs = wkt;\n  }\n  if (geogcs) {\n    //if(wkt.GEOGCS.PRIMEM&&wkt.GEOGCS.PRIMEM.convert){\n    //  wkt.from_greenwich=wkt.GEOGCS.PRIMEM.convert*D2R;\n    //}\n    if (geogcs.DATUM) {\n      wkt.datumCode = geogcs.DATUM.name.toLowerCase();\n    } else {\n      wkt.datumCode = geogcs.name.toLowerCase();\n    }\n    if (wkt.datumCode.slice(0, 2) === 'd_') {\n      wkt.datumCode = wkt.datumCode.slice(2);\n    }\n    if (wkt.datumCode === 'new_zealand_geodetic_datum_1949' || wkt.datumCode === 'new_zealand_1949') {\n      wkt.datumCode = 'nzgd49';\n    }\n    if (wkt.datumCode === 'wgs_1984' || wkt.datumCode === 'world_geodetic_system_1984') {\n      if (wkt.PROJECTION === 'Mercator_Auxiliary_Sphere') {\n        wkt.sphere = true;\n      }\n      wkt.datumCode = 'wgs84';\n    }\n    if (wkt.datumCode.slice(-6) === '_ferro') {\n      wkt.datumCode = wkt.datumCode.slice(0, - 6);\n    }\n    if (wkt.datumCode.slice(-8) === '_jakarta') {\n      wkt.datumCode = wkt.datumCode.slice(0, - 8);\n    }\n    if (~wkt.datumCode.indexOf('belge')) {\n      wkt.datumCode = 'rnb72';\n    }\n    if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {\n      wkt.ellps = geogcs.DATUM.SPHEROID.name.replace('_19', '').replace(/[Cc]larke\\_18/, 'clrk');\n      if (wkt.ellps.toLowerCase().slice(0, 13) === 'international') {\n        wkt.ellps = 'intl';\n      }\n\n      wkt.a = geogcs.DATUM.SPHEROID.a;\n      wkt.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);\n    }\n\n    if (geogcs.DATUM && geogcs.DATUM.TOWGS84) {\n      wkt.datum_params = geogcs.DATUM.TOWGS84;\n    }\n    if (~wkt.datumCode.indexOf('osgb_1936')) {\n      wkt.datumCode = 'osgb36';\n    }\n    if (~wkt.datumCode.indexOf('osni_1952')) {\n      wkt.datumCode = 'osni52';\n    }\n    if (~wkt.datumCode.indexOf('tm65')\n      || ~wkt.datumCode.indexOf('geodetic_datum_of_1965')) {\n      wkt.datumCode = 'ire65';\n    }\n    if (wkt.datumCode === 'ch1903+') {\n      wkt.datumCode = 'ch1903';\n    }\n    if (~wkt.datumCode.indexOf('israel')) {\n      wkt.datumCode = 'isr93';\n    }\n  }\n  if (wkt.b && !isFinite(wkt.b)) {\n    wkt.b = wkt.a;\n  }\n\n  function toMeter(input) {\n    var ratio = wkt.to_meter || 1;\n    return input * ratio;\n  }\n  var renamer = function(a) {\n    return rename(wkt, a);\n  };\n  var list = [\n    ['standard_parallel_1', 'Standard_Parallel_1'],\n    ['standard_parallel_2', 'Standard_Parallel_2'],\n    ['false_easting', 'False_Easting'],\n    ['false_northing', 'False_Northing'],\n    ['central_meridian', 'Central_Meridian'],\n    ['latitude_of_origin', 'Latitude_Of_Origin'],\n    ['latitude_of_origin', 'Central_Parallel'],\n    ['scale_factor', 'Scale_Factor'],\n    ['k0', 'scale_factor'],\n    ['latitude_of_center', 'Latitude_Of_Center'],\n    ['latitude_of_center', 'Latitude_of_center'],\n    ['lat0', 'latitude_of_center', d2r],\n    ['longitude_of_center', 'Longitude_Of_Center'],\n    ['longitude_of_center', 'Longitude_of_center'],\n    ['longc', 'longitude_of_center', d2r],\n    ['x0', 'false_easting', toMeter],\n    ['y0', 'false_northing', toMeter],\n    ['long0', 'central_meridian', d2r],\n    ['lat0', 'latitude_of_origin', d2r],\n    ['lat0', 'standard_parallel_1', d2r],\n    ['lat1', 'standard_parallel_1', d2r],\n    ['lat2', 'standard_parallel_2', d2r],\n    ['azimuth', 'Azimuth'],\n    ['alpha', 'azimuth', d2r],\n    ['srsCode', 'name']\n  ];\n  list.forEach(renamer);\n  if (!wkt.long0 && wkt.longc && (wkt.projName === 'Albers_Conic_Equal_Area' || wkt.projName === 'Lambert_Azimuthal_Equal_Area')) {\n    wkt.long0 = wkt.longc;\n  }\n  if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === 'Stereographic_South_Pole' || wkt.projName === 'Polar Stereographic (variant B)')) {\n    wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);\n    wkt.lat_ts = wkt.lat1;\n  }\n}\nexport default function(wkt) {\n  var lisp = parser(wkt);\n  var type = lisp.shift();\n  var name = lisp.shift();\n  lisp.unshift(['name', name]);\n  lisp.unshift(['type', type]);\n  var obj = {};\n  sExpr(lisp, obj);\n  cleanWKT(obj);\n  return obj;\n}\n","import globals from './global';\nimport parseProj from './projString';\nimport wkt from 'wkt-parser';\n\nfunction defs(name) {\n  /*global console*/\n  var that = this;\n  if (arguments.length === 2) {\n    var def = arguments[1];\n    if (typeof def === 'string') {\n      if (def.charAt(0) === '+') {\n        defs[name] = parseProj(arguments[1]);\n      }\n      else {\n        defs[name] = wkt(arguments[1]);\n      }\n    } else {\n      defs[name] = def;\n    }\n  }\n  else if (arguments.length === 1) {\n    if (Array.isArray(name)) {\n      return name.map(function(v) {\n        if (Array.isArray(v)) {\n          defs.apply(that, v);\n        }\n        else {\n          defs(v);\n        }\n      });\n    }\n    else if (typeof name === 'string') {\n      if (name in defs) {\n        return defs[name];\n      }\n    }\n    else if ('EPSG' in name) {\n      defs['EPSG:' + name.EPSG] = name;\n    }\n    else if ('ESRI' in name) {\n      defs['ESRI:' + name.ESRI] = name;\n    }\n    else if ('IAU2000' in name) {\n      defs['IAU2000:' + name.IAU2000] = name;\n    }\n    else {\n      console.log(name);\n    }\n    return;\n  }\n\n\n}\nglobals(defs);\nexport default defs;\n","export default function(defs) {\n  defs('EPSG:4326', \"+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees\");\n  // defs('EPSG:4269', \"+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees\");\n  // defs('EPSG:3857', \"+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs\");\n\n  defs.WGS84 = defs['EPSG:4326'];\n  // defs['EPSG:3785'] = defs['EPSG:3857']; // maintain backward compat, official code is 3857\n  // defs.GOOGLE = defs['EPSG:3857'];\n  // defs['EPSG:900913'] = defs['EPSG:3857'];\n  // defs['EPSG:102113'] = defs['EPSG:3857'];\n}\n","import defs from './defs';\nimport wkt from 'wkt-parser';\nimport projStr from './projString';\nimport match from './match';\nfunction testObj(code){\n  return typeof code === 'string';\n}\nfunction testDef(code){\n  return code in defs;\n}\n var codeWords = ['PROJECTEDCRS', 'PROJCRS', 'GEOGCS','GEOCCS','PROJCS','LOCAL_CS', 'GEODCRS', 'GEODETICCRS', 'GEODETICDATUM', 'ENGCRS', 'ENGINEERINGCRS'];\nfunction testWKT(code){\n  return codeWords.some(function (word) {\n    return code.indexOf(word) > -1;\n  });\n}\nvar codes = ['3857', '900913', '3785', '102113'];\nfunction checkMercator(item) {\n  var auth = match(item, 'authority');\n  if (!auth) {\n    return;\n  }\n  var code = match(auth, 'epsg');\n  return code && codes.indexOf(code) > -1;\n}\nfunction checkProjStr(item) {\n  var ext = match(item, 'extension');\n  if (!ext) {\n    return;\n  }\n  return match(ext, 'proj4');\n}\nfunction testProj(code){\n  return code[0] === '+';\n}\nfunction parse(code){\n  if (testObj(code)) {\n    //check to see if this is a WKT string\n    if (testDef(code)) {\n      return defs[code];\n    }\n    if (testWKT(code)) {\n      var out = wkt(code);\n      // test of spetial case, due to this being a very common and often malformed\n      if (checkMercator(out)) {\n        return defs['EPSG:3857'];\n      }\n      var maybeProjStr = checkProjStr(out);\n      if (maybeProjStr) {\n        return projStr(maybeProjStr);\n      }\n      return out;\n    }\n    if (testProj(code)) {\n      return projStr(code);\n    }\n  }else{\n    return code;\n  }\n}\n\nexport default parse;\n","export default function(destination, source) {\n  destination = destination || {};\n  var value, property;\n  if (!source) {\n    return destination;\n  }\n  for (property in source) {\n    value = source[property];\n    if (value !== undefined) {\n      destination[property] = value;\n    }\n  }\n  return destination;\n}\n","export function init() {\n  //no-op for longlat\n}\n\nfunction identity(pt) {\n  return pt;\n}\nexport {identity as forward};\nexport {identity as inverse};\nexport var names = [\"longlat\", \"identity\"];\nexport default {\n  init: init,\n  forward: identity,\n  inverse: identity,\n  names: names\n};\n","// import merc from \"./projections/merc\";\nimport longlat from \"./projections/longlat\";\nvar projs = [longlat]; // merc, \nvar names = {};\nvar projStore = [];\n\nfunction add(proj, i) {\n  var len = projStore.length;\n  if (!proj.names) {\n    console.log(i);\n    return true;\n  }\n  projStore[len] = proj;\n  proj.names.forEach(function(n) {\n    names[n.toLowerCase()] = len;\n  });\n  return this;\n}\n\nexport {add};\n\nexport function get(name) {\n  if (!name) {\n    return false;\n  }\n  var n = name.toLowerCase();\n  if (typeof names[n] !== 'undefined' && projStore[names[n]]) {\n    return projStore[names[n]];\n  }\n}\n\nexport function start() {\n  projs.forEach(add);\n}\nexport default {\n  start: start,\n  add: add,\n  get: get\n};\n","var exports = {};\nexport {exports as default};\nexports.MERIT = {\n  a: 6378137.0,\n  rf: 298.257,\n  ellipseName: \"MERIT 1983\"\n};\n\nexports.SGS85 = {\n  a: 6378136.0,\n  rf: 298.257,\n  ellipseName: \"Soviet Geodetic System 85\"\n};\n\nexports.GRS80 = {\n  a: 6378137.0,\n  rf: 298.257222101,\n  ellipseName: \"GRS 1980(IUGG, 1980)\"\n};\n\nexports.IAU76 = {\n  a: 6378140.0,\n  rf: 298.257,\n  ellipseName: \"IAU 1976\"\n};\n\nexports.airy = {\n  a: 6377563.396,\n  b: 6356256.910,\n  ellipseName: \"Airy 1830\"\n};\n\nexports.APL4 = {\n  a: 6378137,\n  rf: 298.25,\n  ellipseName: \"Appl. Physics. 1965\"\n};\n\nexports.NWL9D = {\n  a: 6378145.0,\n  rf: 298.25,\n  ellipseName: \"Naval Weapons Lab., 1965\"\n};\n\nexports.mod_airy = {\n  a: 6377340.189,\n  b: 6356034.446,\n  ellipseName: \"Modified Airy\"\n};\n\nexports.andrae = {\n  a: 6377104.43,\n  rf: 300.0,\n  ellipseName: \"Andrae 1876 (Den., Iclnd.)\"\n};\n\nexports.aust_SA = {\n  a: 6378160.0,\n  rf: 298.25,\n  ellipseName: \"Australian Natl & S. Amer. 1969\"\n};\n\nexports.GRS67 = {\n  a: 6378160.0,\n  rf: 298.2471674270,\n  ellipseName: \"GRS 67(IUGG 1967)\"\n};\n\nexports.bessel = {\n  a: 6377397.155,\n  rf: 299.1528128,\n  ellipseName: \"Bessel 1841\"\n};\n\nexports.bess_nam = {\n  a: 6377483.865,\n  rf: 299.1528128,\n  ellipseName: \"Bessel 1841 (Namibia)\"\n};\n\nexports.clrk66 = {\n  a: 6378206.4,\n  b: 6356583.8,\n  ellipseName: \"Clarke 1866\"\n};\n\nexports.clrk80 = {\n  a: 6378249.145,\n  rf: 293.4663,\n  ellipseName: \"Clarke 1880 mod.\"\n};\n\nexports.clrk58 = {\n  a: 6378293.645208759,\n  rf: 294.2606763692654,\n  ellipseName: \"Clarke 1858\"\n};\n\nexports.CPM = {\n  a: 6375738.7,\n  rf: 334.29,\n  ellipseName: \"Comm. des Poids et Mesures 1799\"\n};\n\nexports.delmbr = {\n  a: 6376428.0,\n  rf: 311.5,\n  ellipseName: \"Delambre 1810 (Belgium)\"\n};\n\nexports.engelis = {\n  a: 6378136.05,\n  rf: 298.2566,\n  ellipseName: \"Engelis 1985\"\n};\n\nexports.evrst30 = {\n  a: 6377276.345,\n  rf: 300.8017,\n  ellipseName: \"Everest 1830\"\n};\n\nexports.evrst48 = {\n  a: 6377304.063,\n  rf: 300.8017,\n  ellipseName: \"Everest 1948\"\n};\n\nexports.evrst56 = {\n  a: 6377301.243,\n  rf: 300.8017,\n  ellipseName: \"Everest 1956\"\n};\n\nexports.evrst69 = {\n  a: 6377295.664,\n  rf: 300.8017,\n  ellipseName: \"Everest 1969\"\n};\n\nexports.evrstSS = {\n  a: 6377298.556,\n  rf: 300.8017,\n  ellipseName: \"Everest (Sabah & Sarawak)\"\n};\n\nexports.fschr60 = {\n  a: 6378166.0,\n  rf: 298.3,\n  ellipseName: \"Fischer (Mercury Datum) 1960\"\n};\n\nexports.fschr60m = {\n  a: 6378155.0,\n  rf: 298.3,\n  ellipseName: \"Fischer 1960\"\n};\n\nexports.fschr68 = {\n  a: 6378150.0,\n  rf: 298.3,\n  ellipseName: \"Fischer 1968\"\n};\n\nexports.helmert = {\n  a: 6378200.0,\n  rf: 298.3,\n  ellipseName: \"Helmert 1906\"\n};\n\nexports.hough = {\n  a: 6378270.0,\n  rf: 297.0,\n  ellipseName: \"Hough\"\n};\n\nexports.intl = {\n  a: 6378388.0,\n  rf: 297.0,\n  ellipseName: \"International 1909 (Hayford)\"\n};\n\nexports.kaula = {\n  a: 6378163.0,\n  rf: 298.24,\n  ellipseName: \"Kaula 1961\"\n};\n\nexports.lerch = {\n  a: 6378139.0,\n  rf: 298.257,\n  ellipseName: \"Lerch 1979\"\n};\n\nexports.mprts = {\n  a: 6397300.0,\n  rf: 191.0,\n  ellipseName: \"Maupertius 1738\"\n};\n\nexports.new_intl = {\n  a: 6378157.5,\n  b: 6356772.2,\n  ellipseName: \"New International 1967\"\n};\n\nexports.plessis = {\n  a: 6376523.0,\n  rf: 6355863.0,\n  ellipseName: \"Plessis 1817 (France)\"\n};\n\nexports.krass = {\n  a: 6378245.0,\n  rf: 298.3,\n  ellipseName: \"Krassovsky, 1942\"\n};\n\nexports.SEasia = {\n  a: 6378155.0,\n  b: 6356773.3205,\n  ellipseName: \"Southeast Asia\"\n};\n\nexports.walbeck = {\n  a: 6376896.0,\n  b: 6355834.8467,\n  ellipseName: \"Walbeck\"\n};\n\nexports.WGS60 = {\n  a: 6378165.0,\n  rf: 298.3,\n  ellipseName: \"WGS 60\"\n};\n\nexports.WGS66 = {\n  a: 6378145.0,\n  rf: 298.25,\n  ellipseName: \"WGS 66\"\n};\n\nexports.WGS7 = {\n  a: 6378135.0,\n  rf: 298.26,\n  ellipseName: \"WGS 72\"\n};\n\nexport var WGS84 = exports.WGS84 = {\n  a: 6378137.0,\n  rf: 298.257223563,\n  ellipseName: \"WGS 84\"\n};\n\nexports.sphere = {\n  a: 6370997.0,\n  b: 6370997.0,\n  ellipseName: \"Normal Sphere (r=6370997)\"\n};\n","var exports = {};\nexport {exports as default};\nexports.wgs84 = {\n  towgs84: \"0,0,0\",\n  ellipse: \"WGS84\",\n  datumName: \"WGS84\"\n};\n\nexports.ch1903 = {\n  towgs84: \"674.374,15.056,405.346\",\n  ellipse: \"bessel\",\n  datumName: \"swiss\"\n};\n\nexports.ggrs87 = {\n  towgs84: \"-199.87,74.79,246.62\",\n  ellipse: \"GRS80\",\n  datumName: \"Greek_Geodetic_Reference_System_1987\"\n};\n\nexports.nad83 = {\n  towgs84: \"0,0,0\",\n  ellipse: \"GRS80\",\n  datumName: \"North_American_Datum_1983\"\n};\n\nexports.nad27 = {\n  nadgrids: \"@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat\",\n  ellipse: \"clrk66\",\n  datumName: \"North_American_Datum_1927\"\n};\n\nexports.potsdam = {\n  towgs84: \"606.0,23.0,413.0\",\n  ellipse: \"bessel\",\n  datumName: \"Potsdam Rauenberg 1950 DHDN\"\n};\n\nexports.carthage = {\n  towgs84: \"-263.0,6.0,431.0\",\n  ellipse: \"clark80\",\n  datumName: \"Carthage 1934 Tunisia\"\n};\n\nexports.hermannskogel = {\n  towgs84: \"653.0,-212.0,449.0\",\n  ellipse: \"bessel\",\n  datumName: \"Hermannskogel\"\n};\n\nexports.osni52 = {\n  towgs84: \"482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15\",\n  ellipse: \"airy\",\n  datumName: \"Irish National\"\n};\n\nexports.ire65 = {\n  towgs84: \"482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15\",\n  ellipse: \"mod_airy\",\n  datumName: \"Ireland 1965\"\n};\n\nexports.rassadiran = {\n  towgs84: \"-133.63,-157.5,-158.62\",\n  ellipse: \"intl\",\n  datumName: \"Rassadiran\"\n};\n\nexports.nzgd49 = {\n  towgs84: \"59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993\",\n  ellipse: \"intl\",\n  datumName: \"New Zealand Geodetic Datum 1949\"\n};\n\nexports.osgb36 = {\n  towgs84: \"446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894\",\n  ellipse: \"airy\",\n  datumName: \"Airy 1830\"\n};\n\nexports.s_jtsk = {\n  towgs84: \"589,76,480\",\n  ellipse: 'bessel',\n  datumName: 'S-JTSK (Ferro)'\n};\n\nexports.beduaram = {\n  towgs84: '-106,-87,188',\n  ellipse: 'clrk80',\n  datumName: 'Beduaram'\n};\n\nexports.gunung_segara = {\n  towgs84: '-403,684,41',\n  ellipse: 'bessel',\n  datumName: 'Gunung Segara Jakarta'\n};\n\nexports.rnb72 = {\n  towgs84: \"106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1\",\n  ellipse: \"intl\",\n  datumName: \"Reseau National Belge 1972\"\n};\n","import parseCode from './parseCode';\nimport extend from './extend';\nimport projections from './projections';\nimport {sphere as dc_sphere, eccentricity as dc_eccentricity} from './deriveConstants';\nimport Datum from './constants/Datum';\nimport datum from './datum';\nimport match from './match';\n\nfunction Projection(srsCode,callback) {\n  if (!(this instanceof Projection)) {\n    return new Projection(srsCode);\n  }\n  callback = callback || function(error){\n    if(error){\n      throw error;\n    }\n  };\n  var json = parseCode(srsCode);\n  if(typeof json !== 'object'){\n    callback(srsCode);\n    return;\n  }\n  var ourProj = Projection.projections.get(json.projName);\n  if(!ourProj){\n    callback(srsCode);\n    return;\n  }\n  if (json.datumCode && json.datumCode !== 'none') {\n    var datumDef = match(Datum, json.datumCode);\n    if (datumDef) {\n      json.datum_params = datumDef.towgs84 ? datumDef.towgs84.split(',') : null;\n      json.ellps = datumDef.ellipse;\n      json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;\n    }\n  }\n  json.k0 = json.k0 || 1.0;\n  json.axis = json.axis || 'enu';\n  json.ellps = json.ellps || 'wgs84';\n  var sphere_ = dc_sphere(json.a, json.b, json.rf, json.ellps, json.sphere);\n  var ecc = dc_eccentricity(sphere_.a, sphere_.b, sphere_.rf, json.R_A);\n  var datumObj = json.datum || datum(json.datumCode, json.datum_params, sphere_.a, sphere_.b, ecc.es, ecc.ep2);\n\n  extend(this, json); // transfer everything over from the projection because we don't know what we'll need\n  extend(this, ourProj); // transfer all the methods from the projection\n\n  // copy the 4 things over we calulated in deriveConstants.sphere\n  this.a = sphere_.a;\n  this.b = sphere_.b;\n  this.rf = sphere_.rf;\n  this.sphere = sphere_.sphere;\n\n  // copy the 3 things we calculated in deriveConstants.eccentricity\n  this.es = ecc.es;\n  this.e = ecc.e;\n  this.ep2 = ecc.ep2;\n\n  // add in the datum object\n  this.datum = datumObj;\n\n  // init the projection\n  this.init();\n\n  // legecy callback from back in the day when it went to spatialreference.org\n  callback(null, this);\n\n}\nProjection.projections = projections;\nProjection.projections.start();\nexport default Projection;\n","import {SIXTH, RA4, RA6, EPSLN} from './constants/values';\nimport {default as Ellipsoid, WGS84} from './constants/Ellipsoid';\nimport match from './match';\n\nexport function eccentricity(a, b, rf, R_A) {\n  var a2 = a * a; // used in geocentric\n  var b2 = b * b; // used in geocentric\n  var es = (a2 - b2) / a2; // e ^ 2\n  var e = 0;\n  if (R_A) {\n    a *= 1 - es * (SIXTH + es * (RA4 + es * RA6));\n    a2 = a * a;\n    es = 0;\n  } else {\n    e = Math.sqrt(es); // eccentricity\n  }\n  var ep2 = (a2 - b2) / b2; // used in geocentric\n  return {\n    es: es,\n    e: e,\n    ep2: ep2\n  };\n}\nexport function sphere(a, b, rf, ellps, sphere) {\n  if (!a) { // do we have an ellipsoid?\n    var ellipse = match(Ellipsoid, ellps);\n    if (!ellipse) {\n      ellipse = WGS84;\n    }\n    a = ellipse.a;\n    b = ellipse.b;\n    rf = ellipse.rf;\n  }\n\n  if (rf && !b) {\n    b = (1.0 - 1.0 / rf) * a;\n  }\n  if (rf === 0 || Math.abs(a - b) < EPSLN) {\n    sphere = true;\n    b = a;\n  }\n  return {\n    a: a,\n    b: b,\n    rf: rf,\n    sphere: sphere\n  };\n}\n","import {PJD_3PARAM, PJD_7PARAM, PJD_WGS84, PJD_NODATUM, SEC_TO_RAD} from './constants/values';\n\nfunction datum(datumCode, datum_params, a, b, es, ep2) {\n  var out = {};\n\n  if (datumCode === undefined || datumCode === 'none') {\n    out.datum_type = PJD_NODATUM;\n  } else {\n    out.datum_type = PJD_WGS84;\n  }\n\n  if (datum_params) {\n    out.datum_params = datum_params.map(parseFloat);\n    if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {\n      out.datum_type = PJD_3PARAM;\n    }\n    if (out.datum_params.length > 3) {\n      if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {\n        out.datum_type = PJD_7PARAM;\n        out.datum_params[3] *= SEC_TO_RAD;\n        out.datum_params[4] *= SEC_TO_RAD;\n        out.datum_params[5] *= SEC_TO_RAD;\n        out.datum_params[6] = (out.datum_params[6] / 1000000.0) + 1.0;\n      }\n    }\n  }\n\n  out.a = a; //datum object also uses these values\n  out.b = b;\n  out.es = es;\n  out.ep2 = ep2;\n  return out;\n}\n\nexport default datum;\n","import {PJD_3PARAM, PJD_7PARAM, PJD_NODATUM} from './constants/values';\n\nimport {geodeticToGeocentric, geocentricToGeodetic, geocentricToWgs84, geocentricFromWgs84, compareDatums} from './datumUtils';\nfunction checkParams(type) {\n  return (type === PJD_3PARAM || type === PJD_7PARAM);\n}\n\nexport default function(source, dest, point) {\n  // Short cut if the datums are identical.\n  if (compareDatums(source, dest)) {\n    return point; // in this case, zero is sucess,\n    // whereas cs_compare_datums returns 1 to indicate TRUE\n    // confusing, should fix this\n  }\n\n  // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest\n  if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {\n    return point;\n  }\n\n  // If this datum requires grid shifts, then apply it to geodetic coordinates.\n\n  // Do we need to go through geocentric coordinates?\n  if (source.es === dest.es && source.a === dest.a && !checkParams(source.datum_type) &&  !checkParams(dest.datum_type)) {\n    return point;\n  }\n\n  // Convert to geocentric coordinates.\n  point = geodeticToGeocentric(point, source.es, source.a);\n  // Convert between datums\n  if (checkParams(source.datum_type)) {\n    point = geocentricToWgs84(point, source.datum_type, source.datum_params);\n  }\n  if (checkParams(dest.datum_type)) {\n    point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);\n  }\n  return geocentricToGeodetic(point, dest.es, dest.a, dest.b);\n\n}\n","'use strict';\nimport {PJD_3PARAM, PJD_7PARAM, HALF_PI} from './constants/values';\nexport function compareDatums(source, dest) {\n  if (source.datum_type !== dest.datum_type) {\n    return false; // false, datums are not equal\n  } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 0.000000000050) {\n    // the tolerance for es is to ensure that GRS80 and WGS84\n    // are considered identical\n    return false;\n  } else if (source.datum_type === PJD_3PARAM) {\n    return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2]);\n  } else if (source.datum_type === PJD_7PARAM) {\n    return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6]);\n  } else {\n    return true; // datums are equal\n  }\n} // cs_compare_datums()\n\n/*\n * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates\n * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),\n * according to the current ellipsoid parameters.\n *\n *    Latitude  : Geodetic latitude in radians                     (input)\n *    Longitude : Geodetic longitude in radians                    (input)\n *    Height    : Geodetic height, in meters                       (input)\n *    X         : Calculated Geocentric X coordinate, in meters    (output)\n *    Y         : Calculated Geocentric Y coordinate, in meters    (output)\n *    Z         : Calculated Geocentric Z coordinate, in meters    (output)\n *\n */\nexport function geodeticToGeocentric(p, es, a) {\n  var Longitude = p.x;\n  var Latitude = p.y;\n  var Height = p.z ? p.z : 0; //Z value not always supplied\n\n  var Rn; /*  Earth radius at location  */\n  var Sin_Lat; /*  Math.sin(Latitude)  */\n  var Sin2_Lat; /*  Square of Math.sin(Latitude)  */\n  var Cos_Lat; /*  Math.cos(Latitude)  */\n\n  /*\n   ** Don't blow up if Latitude is just a little out of the value\n   ** range as it may just be a rounding issue.  Also removed longitude\n   ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.\n   */\n  if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {\n    Latitude = -HALF_PI;\n  } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {\n    Latitude = HALF_PI;\n  } else if (Latitude < -HALF_PI) {\n    /* Latitude out of range */\n    //..reportError('geocent:lat out of range:' + Latitude);\n    return { x: -Infinity, y: -Infinity, z: p.z };\n  } else if (Latitude > HALF_PI) {\n    /* Latitude out of range */\n    return { x: Infinity, y: Infinity, z: p.z };\n  }\n\n  if (Longitude > Math.PI) {\n    Longitude -= (2 * Math.PI);\n  }\n  Sin_Lat = Math.sin(Latitude);\n  Cos_Lat = Math.cos(Latitude);\n  Sin2_Lat = Sin_Lat * Sin_Lat;\n  Rn = a / (Math.sqrt(1.0e0 - es * Sin2_Lat));\n  return {\n    x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),\n    y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),\n    z: ((Rn * (1 - es)) + Height) * Sin_Lat\n  };\n} // cs_geodetic_to_geocentric()\n\nexport function geocentricToGeodetic(p, es, a, b) {\n  /* local defintions and variables */\n  /* end-criterium of loop, accuracy of sin(Latitude) */\n  var genau = 1e-12;\n  var genau2 = (genau * genau);\n  var maxiter = 30;\n\n  var P; /* distance between semi-minor axis and location */\n  var RR; /* distance between center and location */\n  var CT; /* sin of geocentric latitude */\n  var ST; /* cos of geocentric latitude */\n  var RX;\n  var RK;\n  var RN; /* Earth radius at location */\n  var CPHI0; /* cos of start or old geodetic latitude in iterations */\n  var SPHI0; /* sin of start or old geodetic latitude in iterations */\n  var CPHI; /* cos of searched geodetic latitude */\n  var SPHI; /* sin of searched geodetic latitude */\n  var SDPHI; /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */\n  var iter; /* # of continous iteration, max. 30 is always enough (s.a.) */\n\n  var X = p.x;\n  var Y = p.y;\n  var Z = p.z ? p.z : 0.0; //Z value not always supplied\n  var Longitude;\n  var Latitude;\n  var Height;\n\n  P = Math.sqrt(X * X + Y * Y);\n  RR = Math.sqrt(X * X + Y * Y + Z * Z);\n\n  /*      special cases for latitude and longitude */\n  if (P / a < genau) {\n\n    /*  special case, if P=0. (X=0., Y=0.) */\n    Longitude = 0.0;\n\n    /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis\n     *  of ellipsoid (=center of mass), Latitude becomes PI/2 */\n    if (RR / a < genau) {\n      Latitude = HALF_PI;\n      Height = -b;\n      return {\n        x: p.x,\n        y: p.y,\n        z: p.z\n      };\n    }\n  } else {\n    /*  ellipsoidal (geodetic) longitude\n     *  interval: -PI < Longitude <= +PI */\n    Longitude = Math.atan2(Y, X);\n  }\n\n  /* --------------------------------------------------------------\n   * Following iterative algorithm was developped by\n   * \"Institut for Erdmessung\", University of Hannover, July 1988.\n   * Internet: www.ife.uni-hannover.de\n   * Iterative computation of CPHI,SPHI and Height.\n   * Iteration of CPHI and SPHI to 10**-12 radian resp.\n   * 2*10**-7 arcsec.\n   * --------------------------------------------------------------\n   */\n  CT = Z / RR;\n  ST = P / RR;\n  RX = 1.0 / Math.sqrt(1.0 - es * (2.0 - es) * ST * ST);\n  CPHI0 = ST * (1.0 - es) * RX;\n  SPHI0 = CT * RX;\n  iter = 0;\n\n  /* loop to find sin(Latitude) resp. Latitude\n   * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */\n  do {\n    iter++;\n    RN = a / Math.sqrt(1.0 - es * SPHI0 * SPHI0);\n\n    /*  ellipsoidal (geodetic) height */\n    Height = P * CPHI0 + Z * SPHI0 - RN * (1.0 - es * SPHI0 * SPHI0);\n\n    RK = es * RN / (RN + Height);\n    RX = 1.0 / Math.sqrt(1.0 - RK * (2.0 - RK) * ST * ST);\n    CPHI = ST * (1.0 - RK) * RX;\n    SPHI = CT * RX;\n    SDPHI = SPHI * CPHI0 - CPHI * SPHI0;\n    CPHI0 = CPHI;\n    SPHI0 = SPHI;\n  }\n  while (SDPHI * SDPHI > genau2 && iter < maxiter);\n\n  /*      ellipsoidal (geodetic) latitude */\n  Latitude = Math.atan(SPHI / Math.abs(CPHI));\n  return {\n    x: Longitude,\n    y: Latitude,\n    z: Height\n  };\n} // cs_geocentric_to_geodetic()\n\n/****************************************************************/\n// pj_geocentic_to_wgs84( p )\n//  p = point to transform in geocentric coordinates (x,y,z)\n\n\n/** point object, nothing fancy, just allows values to be\n    passed back and forth by reference rather than by value.\n    Other point classes may be used as long as they have\n    x and y properties, which will get modified in the transform method.\n*/\nexport function geocentricToWgs84(p, datum_type, datum_params) {\n\n  if (datum_type === PJD_3PARAM) {\n    // if( x[io] === HUGE_VAL )\n    //    continue;\n    return {\n      x: p.x + datum_params[0],\n      y: p.y + datum_params[1],\n      z: p.z + datum_params[2],\n    };\n  } else if (datum_type === PJD_7PARAM) {\n    var Dx_BF = datum_params[0];\n    var Dy_BF = datum_params[1];\n    var Dz_BF = datum_params[2];\n    var Rx_BF = datum_params[3];\n    var Ry_BF = datum_params[4];\n    var Rz_BF = datum_params[5];\n    var M_BF = datum_params[6];\n    // if( x[io] === HUGE_VAL )\n    //    continue;\n    return {\n      x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,\n      y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,\n      z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF\n    };\n  }\n} // cs_geocentric_to_wgs84\n\n/****************************************************************/\n// pj_geocentic_from_wgs84()\n//  coordinate system definition,\n//  point to transform in geocentric coordinates (x,y,z)\nexport function geocentricFromWgs84(p, datum_type, datum_params) {\n\n  if (datum_type === PJD_3PARAM) {\n    //if( x[io] === HUGE_VAL )\n    //    continue;\n    return {\n      x: p.x - datum_params[0],\n      y: p.y - datum_params[1],\n      z: p.z - datum_params[2],\n    };\n\n  } else if (datum_type === PJD_7PARAM) {\n    var Dx_BF = datum_params[0];\n    var Dy_BF = datum_params[1];\n    var Dz_BF = datum_params[2];\n    var Rx_BF = datum_params[3];\n    var Ry_BF = datum_params[4];\n    var Rz_BF = datum_params[5];\n    var M_BF = datum_params[6];\n    var x_tmp = (p.x - Dx_BF) / M_BF;\n    var y_tmp = (p.y - Dy_BF) / M_BF;\n    var z_tmp = (p.z - Dz_BF) / M_BF;\n    //if( x[io] === HUGE_VAL )\n    //    continue;\n\n    return {\n      x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,\n      y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,\n      z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp\n    };\n  } //cs_geocentric_from_wgs84()\n}\n","export default function(crs, denorm, point) {\n  var xin = point.x,\n    yin = point.y,\n    zin = point.z || 0.0;\n  var v, t, i;\n  var out = {};\n  for (i = 0; i < 3; i++) {\n    if (denorm && i === 2 && point.z === undefined) {\n      continue;\n    }\n    if (i === 0) {\n      v = xin;\n      if (\"ew\".indexOf(crs.axis[i]) !== -1) {\n        t = 'x';\n      } else {\n        t = 'y';\n      }\n\n    }\n    else if (i === 1) {\n      v = yin;\n      if (\"ns\".indexOf(crs.axis[i]) !== -1) {\n        t = 'y';\n      } else {\n        t = 'x';\n      }\n    }\n    else {\n      v = zin;\n      t = 'z';\n    }\n    switch (crs.axis[i]) {\n    case 'e':\n      out[t] = v;\n      break;\n    case 'w':\n      out[t] = -v;\n      break;\n    case 'n':\n      out[t] = v;\n      break;\n    case 's':\n      out[t] = -v;\n      break;\n    case 'u':\n      if (point[t] !== undefined) {\n        out.z = v;\n      }\n      break;\n    case 'd':\n      if (point[t] !== undefined) {\n        out.z = -v;\n      }\n      break;\n    default:\n      //console.log(\"ERROR: unknow axis (\"+crs.axis[i]+\") - check definition of \"+crs.projName);\n      return null;\n    }\n  }\n  return out;\n}\n","export default function (array){\n  var out = {\n    x: array[0],\n    y: array[1]\n  };\n  if (array.length>2) {\n    out.z = array[2];\n  }\n  if (array.length>3) {\n    out.m = array[3];\n  }\n  return out;\n}","export default function (point) {\n  checkCoord(point.x);\n  checkCoord(point.y);\n}\nfunction checkCoord(num) {\n  if (typeof Number.isFinite === 'function') {\n    if (Number.isFinite(num)) {\n      return;\n    }\n    throw new TypeError('coordinates must be finite numbers');\n  }\n  if (typeof num !== 'number' || num !== num || !isFinite(num)) {\n    throw new TypeError('coordinates must be finite numbers');\n  }\n}\n","import {D2R, R2D, PJD_3PARAM, PJD_7PARAM} from './constants/values';\nimport datum_transform from './datum_transform';\nimport adjust_axis from './adjust_axis';\nimport proj from './Proj';\nimport toPoint from './common/toPoint';\nimport checkSanity from './checkSanity';\n\nfunction checkNotWGS(source, dest) {\n  return ((source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM) && dest.datumCode !== 'WGS84') || ((dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM) && source.datumCode !== 'WGS84');\n}\n\nexport default function transform(source, dest, point) {\n  var wgs84;\n  if (Array.isArray(point)) {\n    point = toPoint(point);\n  }\n  checkSanity(point);\n  // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84\n  if (source.datum && dest.datum && checkNotWGS(source, dest)) {\n    wgs84 = new proj('WGS84');\n    point = transform(source, wgs84, point);\n    source = wgs84;\n  }\n  // DGR, 2010/11/12\n  if (source.axis !== 'enu') {\n    point = adjust_axis(source, false, point);\n  }\n  // Transform source points to long/lat, if they aren't already.\n  if (source.projName === 'longlat') {\n    point = {\n      x: point.x * D2R,\n      y: point.y * D2R,\n      z: point.z || 0\n    };\n  } else {\n    if (source.to_meter) {\n      point = {\n        x: point.x * source.to_meter,\n        y: point.y * source.to_meter,\n        z: point.z || 0\n      };\n    }\n    point = source.inverse(point); // Convert Cartesian to longlat\n    if (!point) {\n      return;\n    }\n  }\n  // Adjust for the prime meridian if necessary\n  if (source.from_greenwich) {\n    point.x += source.from_greenwich;\n  }\n\n  // Convert datums if needed, and if possible.\n  point = datum_transform(source.datum, dest.datum, point);\n\n  // Adjust for the prime meridian if necessary\n  if (dest.from_greenwich) {\n    point = {\n      x: point.x - dest.from_greenwich,\n      y: point.y,\n      z: point.z || 0\n    };\n  }\n\n  if (dest.projName === 'longlat') {\n    // convert radians to decimal degrees\n    point = {\n      x: point.x * R2D,\n      y: point.y * R2D,\n      z: point.z || 0\n    };\n  } else { // else project\n    point = dest.forward(point);\n    if (dest.to_meter) {\n      point = {\n        x: point.x / dest.to_meter,\n        y: point.y / dest.to_meter,\n        z: point.z || 0\n      };\n    }\n  }\n\n  // DGR, 2010/11/12\n  if (dest.axis !== 'enu') {\n    return adjust_axis(dest, true, point);\n  }\n\n  return point;\n}\n","import proj from './Proj';\nimport transform from './transform';\nvar wgs84 = proj('WGS84');\n\nfunction transformer(from, to, coords) {\n  var transformedArray, out, keys;\n  if (Array.isArray(coords)) {\n    transformedArray = transform(from, to, coords) || {x: NaN, y: NaN};\n    if (coords.length > 2) {\n      if ((typeof from.name !== 'undefined' && from.name === 'geocent') || (typeof to.name !== 'undefined' && to.name === 'geocent')) {\n        if (typeof transformedArray.z === 'number') {\n          return [transformedArray.x, transformedArray.y, transformedArray.z].concat(coords.splice(3));\n        } else {\n          return [transformedArray.x, transformedArray.y, coords[2]].concat(coords.splice(3));\n        }\n      } else {\n        return [transformedArray.x, transformedArray.y].concat(coords.splice(2));\n      }\n    } else {\n      return [transformedArray.x, transformedArray.y];\n    }\n  } else {\n    out = transform(from, to, coords);\n    keys = Object.keys(coords);\n    if (keys.length === 2) {\n      return out;\n    }\n    keys.forEach(function (key) {\n      if ((typeof from.name !== 'undefined' && from.name === 'geocent') || (typeof to.name !== 'undefined' && to.name === 'geocent')) {\n        if (key === 'x' || key === 'y' || key === 'z') {\n          return;\n        }\n      } else {\n        if (key === 'x' || key === 'y') {\n          return;\n        }\n      }\n      out[key] = coords[key];\n    });\n    return out;\n  }\n}\n\nfunction checkProj(item) {\n  if (item instanceof proj) {\n    return item;\n  }\n  if (item.oProj) {\n    return item.oProj;\n  }\n  return proj(item);\n}\n\nfunction proj4(fromProj, toProj, coord) {\n  fromProj = checkProj(fromProj);\n  var single = false;\n  var obj;\n  if (typeof toProj === 'undefined') {\n    toProj = fromProj;\n    fromProj = wgs84;\n    single = true;\n  } else if (typeof toProj.x !== 'undefined' || Array.isArray(toProj)) {\n    coord = toProj;\n    toProj = fromProj;\n    fromProj = wgs84;\n    single = true;\n  }\n  toProj = checkProj(toProj);\n  if (coord) {\n    return transformer(fromProj, toProj, coord);\n  } else {\n    obj = {\n      forward: function (coords) {\n        return transformer(fromProj, toProj, coords);\n      },\n      inverse: function (coords) {\n        return transformer(toProj, fromProj, coords);\n      }\n    };\n    if (single) {\n      obj.oProj = toProj;\n    }\n    return obj;\n  }\n}\nexport default proj4;","\n\n\n/**\n * UTM zones are grouped, and assigned to one of a group of 6\n * sets.\n *\n * {int} @private\n */\nvar NUM_100K_SETS = 6;\n\n/**\n * The column letters (for easting) of the lower left value, per\n * set.\n *\n * {string} @private\n */\nvar SET_ORIGIN_COLUMN_LETTERS = 'AJSAJS';\n\n/**\n * The row letters (for northing) of the lower left value, per\n * set.\n *\n * {string} @private\n */\nvar SET_ORIGIN_ROW_LETTERS = 'AFAFAF';\n\nvar A = 65; // A\nvar I = 73; // I\nvar O = 79; // O\nvar V = 86; // V\nvar Z = 90; // Z\nexport default {\n  forward: forward,\n  inverse: inverse,\n  toPoint: toPoint\n};\n/**\n * Conversion of lat/lon to MGRS.\n *\n * @param {object} ll Object literal with lat and lon properties on a\n *     WGS84 ellipsoid.\n * @param {int} accuracy Accuracy in digits (5 for 1 m, 4 for 10 m, 3 for\n *      100 m, 2 for 1000 m or 1 for 10000 m). Optional, default is 5.\n * @return {string} the MGRS string for the given location and accuracy.\n */\nexport function forward(ll, accuracy) {\n  accuracy = accuracy || 5; // default accuracy 1m\n  return encode(LLtoUTM({\n    lat: ll[1],\n    lon: ll[0]\n  }), accuracy);\n};\n\n/**\n * Conversion of MGRS to lat/lon.\n *\n * @param {string} mgrs MGRS string.\n * @return {array} An array with left (longitude), bottom (latitude), right\n *     (longitude) and top (latitude) values in WGS84, representing the\n *     bounding box for the provided MGRS reference.\n */\nexport function inverse(mgrs) {\n  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));\n  if (bbox.lat && bbox.lon) {\n    return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];\n  }\n  return [bbox.left, bbox.bottom, bbox.right, bbox.top];\n};\n\nexport function toPoint(mgrs) {\n  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));\n  if (bbox.lat && bbox.lon) {\n    return [bbox.lon, bbox.lat];\n  }\n  return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];\n};\n/**\n * Conversion from degrees to radians.\n *\n * @private\n * @param {number} deg the angle in degrees.\n * @return {number} the angle in radians.\n */\nfunction degToRad(deg) {\n  return (deg * (Math.PI / 180.0));\n}\n\n/**\n * Conversion from radians to degrees.\n *\n * @private\n * @param {number} rad the angle in radians.\n * @return {number} the angle in degrees.\n */\nfunction radToDeg(rad) {\n  return (180.0 * (rad / Math.PI));\n}\n\n/**\n * Converts a set of Longitude and Latitude co-ordinates to UTM\n * using the WGS84 ellipsoid.\n *\n * @private\n * @param {object} ll Object literal with lat and lon properties\n *     representing the WGS84 coordinate to be converted.\n * @return {object} Object literal containing the UTM value with easting,\n *     northing, zoneNumber and zoneLetter properties, and an optional\n *     accuracy property in digits. Returns null if the conversion failed.\n */\nfunction LLtoUTM(ll) {\n  var Lat = ll.lat;\n  var Long = ll.lon;\n  var a = 6378137.0; //ellip.radius;\n  var eccSquared = 0.00669438; //ellip.eccsq;\n  var k0 = 0.9996;\n  var LongOrigin;\n  var eccPrimeSquared;\n  var N, T, C, A, M;\n  var LatRad = degToRad(Lat);\n  var LongRad = degToRad(Long);\n  var LongOriginRad;\n  var ZoneNumber;\n  // (int)\n  ZoneNumber = Math.floor((Long + 180) / 6) + 1;\n\n  //Make sure the longitude 180.00 is in Zone 60\n  if (Long === 180) {\n    ZoneNumber = 60;\n  }\n\n  // Special zone for Norway\n  if (Lat >= 56.0 && Lat < 64.0 && Long >= 3.0 && Long < 12.0) {\n    ZoneNumber = 32;\n  }\n\n  // Special zones for Svalbard\n  if (Lat >= 72.0 && Lat < 84.0) {\n    if (Long >= 0.0 && Long < 9.0) {\n      ZoneNumber = 31;\n    }\n    else if (Long >= 9.0 && Long < 21.0) {\n      ZoneNumber = 33;\n    }\n    else if (Long >= 21.0 && Long < 33.0) {\n      ZoneNumber = 35;\n    }\n    else if (Long >= 33.0 && Long < 42.0) {\n      ZoneNumber = 37;\n    }\n  }\n\n  LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3; //+3 puts origin\n  // in middle of\n  // zone\n  LongOriginRad = degToRad(LongOrigin);\n\n  eccPrimeSquared = (eccSquared) / (1 - eccSquared);\n\n  N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));\n  T = Math.tan(LatRad) * Math.tan(LatRad);\n  C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);\n  A = Math.cos(LatRad) * (LongRad - LongOriginRad);\n\n  M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - (35 * eccSquared * eccSquared * eccSquared / 3072) * Math.sin(6 * LatRad));\n\n  var UTMEasting = (k0 * N * (A + (1 - T + C) * A * A * A / 6.0 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120.0) + 500000.0);\n\n  var UTMNorthing = (k0 * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24.0 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720.0)));\n  if (Lat < 0.0) {\n    UTMNorthing += 10000000.0; //10000000 meter offset for\n    // southern hemisphere\n  }\n\n  return {\n    northing: Math.round(UTMNorthing),\n    easting: Math.round(UTMEasting),\n    zoneNumber: ZoneNumber,\n    zoneLetter: getLetterDesignator(Lat)\n  };\n}\n\n/**\n * Converts UTM coords to lat/long, using the WGS84 ellipsoid. This is a convenience\n * class where the Zone can be specified as a single string eg.\"60N\" which\n * is then broken down into the ZoneNumber and ZoneLetter.\n *\n * @private\n * @param {object} utm An object literal with northing, easting, zoneNumber\n *     and zoneLetter properties. If an optional accuracy property is\n *     provided (in meters), a bounding box will be returned instead of\n *     latitude and longitude.\n * @return {object} An object literal containing either lat and lon values\n *     (if no accuracy was provided), or top, right, bottom and left values\n *     for the bounding box calculated according to the provided accuracy.\n *     Returns null if the conversion failed.\n */\nfunction UTMtoLL(utm) {\n\n  var UTMNorthing = utm.northing;\n  var UTMEasting = utm.easting;\n  var zoneLetter = utm.zoneLetter;\n  var zoneNumber = utm.zoneNumber;\n  // check the ZoneNummber is valid\n  if (zoneNumber < 0 || zoneNumber > 60) {\n    return null;\n  }\n\n  var k0 = 0.9996;\n  var a = 6378137.0; //ellip.radius;\n  var eccSquared = 0.00669438; //ellip.eccsq;\n  var eccPrimeSquared;\n  var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));\n  var N1, T1, C1, R1, D, M;\n  var LongOrigin;\n  var mu, phi1Rad;\n\n  // remove 500,000 meter offset for longitude\n  var x = UTMEasting - 500000.0;\n  var y = UTMNorthing;\n\n  // We must know somehow if we are in the Northern or Southern\n  // hemisphere, this is the only time we use the letter So even\n  // if the Zone letter isn't exactly correct it should indicate\n  // the hemisphere correctly\n  if (zoneLetter < 'N') {\n    y -= 10000000.0; // remove 10,000,000 meter offset used\n    // for southern hemisphere\n  }\n\n  // There are 60 zones with zone 1 being at West -180 to -174\n  LongOrigin = (zoneNumber - 1) * 6 - 180 + 3; // +3 puts origin\n  // in middle of\n  // zone\n\n  eccPrimeSquared = (eccSquared) / (1 - eccSquared);\n\n  M = y / k0;\n  mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));\n\n  phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + (151 * e1 * e1 * e1 / 96) * Math.sin(6 * mu);\n  // double phi1 = ProjMath.radToDeg(phi1Rad);\n\n  N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));\n  T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);\n  C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);\n  R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);\n  D = x / (N1 * k0);\n\n  var lat = phi1Rad - (N1 * Math.tan(phi1Rad) / R1) * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1) * D * D * D * D * D * D / 720);\n  lat = radToDeg(lat);\n\n  var lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);\n  lon = LongOrigin + radToDeg(lon);\n\n  var result;\n  if (utm.accuracy) {\n    var topRight = UTMtoLL({\n      northing: utm.northing + utm.accuracy,\n      easting: utm.easting + utm.accuracy,\n      zoneLetter: utm.zoneLetter,\n      zoneNumber: utm.zoneNumber\n    });\n    result = {\n      top: topRight.lat,\n      right: topRight.lon,\n      bottom: lat,\n      left: lon\n    };\n  }\n  else {\n    result = {\n      lat: lat,\n      lon: lon\n    };\n  }\n  return result;\n}\n\n/**\n * Calculates the MGRS letter designator for the given latitude.\n *\n * @private\n * @param {number} lat The latitude in WGS84 to get the letter designator\n *     for.\n * @return {char} The letter designator.\n */\nfunction getLetterDesignator(lat) {\n  //This is here as an error flag to show that the Latitude is\n  //outside MGRS limits\n  var LetterDesignator = 'Z';\n\n  if ((84 >= lat) && (lat >= 72)) {\n    LetterDesignator = 'X';\n  }\n  else if ((72 > lat) && (lat >= 64)) {\n    LetterDesignator = 'W';\n  }\n  else if ((64 > lat) && (lat >= 56)) {\n    LetterDesignator = 'V';\n  }\n  else if ((56 > lat) && (lat >= 48)) {\n    LetterDesignator = 'U';\n  }\n  else if ((48 > lat) && (lat >= 40)) {\n    LetterDesignator = 'T';\n  }\n  else if ((40 > lat) && (lat >= 32)) {\n    LetterDesignator = 'S';\n  }\n  else if ((32 > lat) && (lat >= 24)) {\n    LetterDesignator = 'R';\n  }\n  else if ((24 > lat) && (lat >= 16)) {\n    LetterDesignator = 'Q';\n  }\n  else if ((16 > lat) && (lat >= 8)) {\n    LetterDesignator = 'P';\n  }\n  else if ((8 > lat) && (lat >= 0)) {\n    LetterDesignator = 'N';\n  }\n  else if ((0 > lat) && (lat >= -8)) {\n    LetterDesignator = 'M';\n  }\n  else if ((-8 > lat) && (lat >= -16)) {\n    LetterDesignator = 'L';\n  }\n  else if ((-16 > lat) && (lat >= -24)) {\n    LetterDesignator = 'K';\n  }\n  else if ((-24 > lat) && (lat >= -32)) {\n    LetterDesignator = 'J';\n  }\n  else if ((-32 > lat) && (lat >= -40)) {\n    LetterDesignator = 'H';\n  }\n  else if ((-40 > lat) && (lat >= -48)) {\n    LetterDesignator = 'G';\n  }\n  else if ((-48 > lat) && (lat >= -56)) {\n    LetterDesignator = 'F';\n  }\n  else if ((-56 > lat) && (lat >= -64)) {\n    LetterDesignator = 'E';\n  }\n  else if ((-64 > lat) && (lat >= -72)) {\n    LetterDesignator = 'D';\n  }\n  else if ((-72 > lat) && (lat >= -80)) {\n    LetterDesignator = 'C';\n  }\n  return LetterDesignator;\n}\n\n/**\n * Encodes a UTM location as MGRS string.\n *\n * @private\n * @param {object} utm An object literal with easting, northing,\n *     zoneLetter, zoneNumber\n * @param {number} accuracy Accuracy in digits (1-5).\n * @return {string} MGRS string for the given UTM location.\n */\nfunction encode(utm, accuracy) {\n  // prepend with leading zeroes\n  var seasting = \"00000\" + utm.easting,\n    snorthing = \"00000\" + utm.northing;\n\n  return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);\n}\n\n/**\n * Get the two letter 100k designator for a given UTM easting,\n * northing and zone number value.\n *\n * @private\n * @param {number} easting\n * @param {number} northing\n * @param {number} zoneNumber\n * @return the two letter 100k designator for the given UTM location.\n */\nfunction get100kID(easting, northing, zoneNumber) {\n  var setParm = get100kSetForZone(zoneNumber);\n  var setColumn = Math.floor(easting / 100000);\n  var setRow = Math.floor(northing / 100000) % 20;\n  return getLetter100kID(setColumn, setRow, setParm);\n}\n\n/**\n * Given a UTM zone number, figure out the MGRS 100K set it is in.\n *\n * @private\n * @param {number} i An UTM zone number.\n * @return {number} the 100k set the UTM zone is in.\n */\nfunction get100kSetForZone(i) {\n  var setParm = i % NUM_100K_SETS;\n  if (setParm === 0) {\n    setParm = NUM_100K_SETS;\n  }\n\n  return setParm;\n}\n\n/**\n * Get the two-letter MGRS 100k designator given information\n * translated from the UTM northing, easting and zone number.\n *\n * @private\n * @param {number} column the column index as it relates to the MGRS\n *        100k set spreadsheet, created from the UTM easting.\n *        Values are 1-8.\n * @param {number} row the row index as it relates to the MGRS 100k set\n *        spreadsheet, created from the UTM northing value. Values\n *        are from 0-19.\n * @param {number} parm the set block, as it relates to the MGRS 100k set\n *        spreadsheet, created from the UTM zone. Values are from\n *        1-60.\n * @return two letter MGRS 100k code.\n */\nfunction getLetter100kID(column, row, parm) {\n  // colOrigin and rowOrigin are the letters at the origin of the set\n  var index = parm - 1;\n  var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);\n  var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);\n\n  // colInt and rowInt are the letters to build to return\n  var colInt = colOrigin + column - 1;\n  var rowInt = rowOrigin + row;\n  var rollover = false;\n\n  if (colInt > Z) {\n    colInt = colInt - Z + A - 1;\n    rollover = true;\n  }\n\n  if (colInt === I || (colOrigin < I && colInt > I) || ((colInt > I || colOrigin < I) && rollover)) {\n    colInt++;\n  }\n\n  if (colInt === O || (colOrigin < O && colInt > O) || ((colInt > O || colOrigin < O) && rollover)) {\n    colInt++;\n\n    if (colInt === I) {\n      colInt++;\n    }\n  }\n\n  if (colInt > Z) {\n    colInt = colInt - Z + A - 1;\n  }\n\n  if (rowInt > V) {\n    rowInt = rowInt - V + A - 1;\n    rollover = true;\n  }\n  else {\n    rollover = false;\n  }\n\n  if (((rowInt === I) || ((rowOrigin < I) && (rowInt > I))) || (((rowInt > I) || (rowOrigin < I)) && rollover)) {\n    rowInt++;\n  }\n\n  if (((rowInt === O) || ((rowOrigin < O) && (rowInt > O))) || (((rowInt > O) || (rowOrigin < O)) && rollover)) {\n    rowInt++;\n\n    if (rowInt === I) {\n      rowInt++;\n    }\n  }\n\n  if (rowInt > V) {\n    rowInt = rowInt - V + A - 1;\n  }\n\n  var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);\n  return twoLetter;\n}\n\n/**\n * Decode the UTM parameters from a MGRS string.\n *\n * @private\n * @param {string} mgrsString an UPPERCASE coordinate string is expected.\n * @return {object} An object literal with easting, northing, zoneLetter,\n *     zoneNumber and accuracy (in meters) properties.\n */\nfunction decode(mgrsString) {\n\n  if (mgrsString && mgrsString.length === 0) {\n    throw (\"MGRSPoint coverting from nothing\");\n  }\n\n  var length = mgrsString.length;\n\n  var hunK = null;\n  var sb = \"\";\n  var testChar;\n  var i = 0;\n\n  // get Zone number\n  while (!(/[A-Z]/).test(testChar = mgrsString.charAt(i))) {\n    if (i >= 2) {\n      throw (\"MGRSPoint bad conversion from: \" + mgrsString);\n    }\n    sb += testChar;\n    i++;\n  }\n\n  var zoneNumber = parseInt(sb, 10);\n\n  if (i === 0 || i + 3 > length) {\n    // A good MGRS string has to be 4-5 digits long,\n    // ##AAA/#AAA at least.\n    throw (\"MGRSPoint bad conversion from: \" + mgrsString);\n  }\n\n  var zoneLetter = mgrsString.charAt(i++);\n\n  // Should we check the zone letter here? Why not.\n  if (zoneLetter <= 'A' || zoneLetter === 'B' || zoneLetter === 'Y' || zoneLetter >= 'Z' || zoneLetter === 'I' || zoneLetter === 'O') {\n    throw (\"MGRSPoint zone letter \" + zoneLetter + \" not handled: \" + mgrsString);\n  }\n\n  hunK = mgrsString.substring(i, i += 2);\n\n  var set = get100kSetForZone(zoneNumber);\n\n  var east100k = getEastingFromChar(hunK.charAt(0), set);\n  var north100k = getNorthingFromChar(hunK.charAt(1), set);\n\n  // We have a bug where the northing may be 2000000 too low.\n  // How\n  // do we know when to roll over?\n\n  while (north100k < getMinNorthing(zoneLetter)) {\n    north100k += 2000000;\n  }\n\n  // calculate the char index for easting/northing separator\n  var remainder = length - i;\n\n  if (remainder % 2 !== 0) {\n    throw (\"MGRSPoint has to have an even number \\nof digits after the zone letter and two 100km letters - front \\nhalf for easting meters, second half for \\nnorthing meters\" + mgrsString);\n  }\n\n  var sep = remainder / 2;\n\n  var sepEasting = 0.0;\n  var sepNorthing = 0.0;\n  var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;\n  if (sep > 0) {\n    accuracyBonus = 100000.0 / Math.pow(10, sep);\n    sepEastingString = mgrsString.substring(i, i + sep);\n    sepEasting = parseFloat(sepEastingString) * accuracyBonus;\n    sepNorthingString = mgrsString.substring(i + sep);\n    sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;\n  }\n\n  easting = sepEasting + east100k;\n  northing = sepNorthing + north100k;\n\n  return {\n    easting: easting,\n    northing: northing,\n    zoneLetter: zoneLetter,\n    zoneNumber: zoneNumber,\n    accuracy: accuracyBonus\n  };\n}\n\n/**\n * Given the first letter from a two-letter MGRS 100k zone, and given the\n * MGRS table set for the zone number, figure out the easting value that\n * should be added to the other, secondary easting value.\n *\n * @private\n * @param {char} e The first letter from a two-letter MGRS 100k zone.\n * @param {number} set The MGRS table set for the zone number.\n * @return {number} The easting value for the given letter and set.\n */\nfunction getEastingFromChar(e, set) {\n  // colOrigin is the letter at the origin of the set for the\n  // column\n  var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);\n  var eastingValue = 100000.0;\n  var rewindMarker = false;\n\n  while (curCol !== e.charCodeAt(0)) {\n    curCol++;\n    if (curCol === I) {\n      curCol++;\n    }\n    if (curCol === O) {\n      curCol++;\n    }\n    if (curCol > Z) {\n      if (rewindMarker) {\n        throw (\"Bad character: \" + e);\n      }\n      curCol = A;\n      rewindMarker = true;\n    }\n    eastingValue += 100000.0;\n  }\n\n  return eastingValue;\n}\n\n/**\n * Given the second letter from a two-letter MGRS 100k zone, and given the\n * MGRS table set for the zone number, figure out the northing value that\n * should be added to the other, secondary northing value. You have to\n * remember that Northings are determined from the equator, and the vertical\n * cycle of letters mean a 2000000 additional northing meters. This happens\n * approx. every 18 degrees of latitude. This method does *NOT* count any\n * additional northings. You have to figure out how many 2000000 meters need\n * to be added for the zone letter of the MGRS coordinate.\n *\n * @private\n * @param {char} n Second letter of the MGRS 100k zone\n * @param {number} set The MGRS table set number, which is dependent on the\n *     UTM zone number.\n * @return {number} The northing value for the given letter and set.\n */\nfunction getNorthingFromChar(n, set) {\n\n  if (n > 'V') {\n    throw (\"MGRSPoint given invalid Northing \" + n);\n  }\n\n  // rowOrigin is the letter at the origin of the set for the\n  // column\n  var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);\n  var northingValue = 0.0;\n  var rewindMarker = false;\n\n  while (curRow !== n.charCodeAt(0)) {\n    curRow++;\n    if (curRow === I) {\n      curRow++;\n    }\n    if (curRow === O) {\n      curRow++;\n    }\n    // fixing a bug making whole application hang in this loop\n    // when 'n' is a wrong character\n    if (curRow > V) {\n      if (rewindMarker) { // making sure that this loop ends\n        throw (\"Bad character: \" + n);\n      }\n      curRow = A;\n      rewindMarker = true;\n    }\n    northingValue += 100000.0;\n  }\n\n  return northingValue;\n}\n\n/**\n * The function getMinNorthing returns the minimum northing value of a MGRS\n * zone.\n *\n * Ported from Geotrans' c Lattitude_Band_Value structure table.\n *\n * @private\n * @param {char} zoneLetter The MGRS zone to get the min northing for.\n * @return {number}\n */\nfunction getMinNorthing(zoneLetter) {\n  var northing;\n  switch (zoneLetter) {\n  case 'C':\n    northing = 1100000.0;\n    break;\n  case 'D':\n    northing = 2000000.0;\n    break;\n  case 'E':\n    northing = 2800000.0;\n    break;\n  case 'F':\n    northing = 3700000.0;\n    break;\n  case 'G':\n    northing = 4600000.0;\n    break;\n  case 'H':\n    northing = 5500000.0;\n    break;\n  case 'J':\n    northing = 6400000.0;\n    break;\n  case 'K':\n    northing = 7300000.0;\n    break;\n  case 'L':\n    northing = 8200000.0;\n    break;\n  case 'M':\n    northing = 9100000.0;\n    break;\n  case 'N':\n    northing = 0.0;\n    break;\n  case 'P':\n    northing = 800000.0;\n    break;\n  case 'Q':\n    northing = 1700000.0;\n    break;\n  case 'R':\n    northing = 2600000.0;\n    break;\n  case 'S':\n    northing = 3500000.0;\n    break;\n  case 'T':\n    northing = 4400000.0;\n    break;\n  case 'U':\n    northing = 5300000.0;\n    break;\n  case 'V':\n    northing = 6200000.0;\n    break;\n  case 'W':\n    northing = 7000000.0;\n    break;\n  case 'X':\n    northing = 7900000.0;\n    break;\n  default:\n    northing = -1.0;\n  }\n  if (northing >= 0.0) {\n    return northing;\n  }\n  else {\n    throw (\"Invalid zone letter: \" + zoneLetter);\n  }\n\n}\n","import {toPoint, forward} from 'mgrs';\n\nfunction Point(x, y, z) {\n  if (!(this instanceof Point)) {\n    return new Point(x, y, z);\n  }\n  if (Array.isArray(x)) {\n    this.x = x[0];\n    this.y = x[1];\n    this.z = x[2] || 0.0;\n  } else if(typeof x === 'object') {\n    this.x = x.x;\n    this.y = x.y;\n    this.z = x.z || 0.0;\n  } else if (typeof x === 'string' && typeof y === 'undefined') {\n    var coords = x.split(',');\n    this.x = parseFloat(coords[0], 10);\n    this.y = parseFloat(coords[1], 10);\n    this.z = parseFloat(coords[2], 10) || 0.0;\n  } else {\n    this.x = x;\n    this.y = y;\n    this.z = z || 0.0;\n  }\n  console.warn('proj4.Point will be removed in version 3, use proj4.toPoint');\n}\n\nPoint.fromMGRS = function(mgrsStr) {\n  return new Point(toPoint(mgrsStr));\n};\nPoint.prototype.toMGRS = function(accuracy) {\n  return forward([this.x, this.y], accuracy);\n};\nexport default Point;\n","import proj4 from './core';\nimport Proj from \"./Proj\";\nimport Point from \"./Point\";\nimport common from \"./common/toPoint\";\nimport defs from \"./defs\";\nimport transform from \"./transform\";\nimport mgrs from \"mgrs\";\nimport includedProjections from \"../projs\";\n\nproj4.defaultDatum = 'WGS84'; //default datum\nproj4.Proj = Proj;\nproj4.WGS84 = new proj4.Proj('WGS84');\nproj4.Point = Point;\nproj4.toPoint = common;\nproj4.defs = defs;\nproj4.transform = transform;\nproj4.mgrs = mgrs;\nproj4.version = '__VERSION__';\nincludedProjections(proj4);\nexport default proj4;\n"],"names":["SEC_TO_RAD","HALF_PI","Math","PI","EPSLN","D2R","R2D","FORTPI","TWO_PI","SPI","exports","greenwich","lisbon","paris","bogota","madrid","rome","bern","jakarta","ferro","brussels","stockholm","athens","oslo","ft","to_meter","us-ft","ignoredChar","match","obj","key","testkey","keys","Object","lkey","toLowerCase","replace","i","length","defData","paramName","paramVal","paramOutname","self","paramObj","split","map","v","trim","filter","a","reduce","p","push","params","proj","datum","rf","parseFloat","lat_0","lat0","lat_1","lat1","lat_2","lat2","lat_ts","lon_0","long0","lon_1","long1","lon_2","long2","alpha","lonc","longc","x_0","x0","y_0","y0","k_0","k0","k","b","r_a","R_A","zone","parseInt","south","utmSouth","towgs84","datum_params","units","unit","from_greenwich","pm","PrimeMeridian","nadgrids","datumCode","axis","indexOf","substr","whitespace","latin","keyword","endThings","digets","Parser","text","Error","this","level","place","root","stack","currentObject","state","mapit","value","Array","isArray","unshift","thing","out","newObj","item","sExpr","shift","name","convert","prototype","readCharicter","char","test","neutral","quoted","afterquote","number","word","afterItem","pop","newObjects","output","d2r","input","wkt","lisp","type","projName","local","PROJECTION","AXIS","axisOrder","ii","descriptor","UNIT","DATUM","SPHEROID","geogcs","GEOGCS","toMeter","slice","sphere","ellps","TOWGS84","isFinite","forEach","outName","inName","cleanWKT","defs","that","arguments","def","charAt","parseProj","apply","EPSG","ESRI","IAU2000","console","log","WGS84","globals","codeWords","codes","parse","code","testObj","testDef","some","testWKT","auth","checkMercator","maybeProjStr","ext","checkProjStr","projStr","testProj","destination","source","property","undefined","identity","pt","projs","init","forward","inverse","names","projStore","add","len","n","start","get","ellipseName","Projection","srsCode","callback","error","json","parseCode","ourProj","projections","datumDef","Datum","ellipse","datumName","a2","b2","es","e","sphere_","Ellipsoid","abs","dc_sphere","ecc","sqrt","ep2","datumObj","datum_type","extend","checkParams","dest","point","compareDatums","Rn","Sin_Lat","Sin2_Lat","Cos_Lat","Longitude","x","Latitude","y","Height","z","Infinity","sin","cos","geodeticToGeocentric","Dx_BF","Dy_BF","Dz_BF","Rx_BF","Ry_BF","Rz_BF","M_BF","geocentricToWgs84","x_tmp","y_tmp","z_tmp","geocentricFromWgs84","P","RR","CT","ST","RX","RK","RN","CPHI0","SPHI0","CPHI","SPHI","SDPHI","iter","X","Y","Z","atan2","atan","geocentricToGeodetic","crs","denorm","t","xin","yin","zin","array","m","checkCoord","num","Number","TypeError","transform","wgs84","toPoint","checkSanity","checkNotWGS","adjust_axis","datum_transform","ch1903","ggrs87","nad83","nad27","potsdam","carthage","hermannskogel","osni52","ire65","rassadiran","nzgd49","osgb36","s_jtsk","beduaram","gunung_segara","rnb72","transformer","from","to","coords","transformedArray","NaN","concat","splice","checkProj","oProj","proj4","fromProj","toProj","coord","single","A","I","O","mgrs","bbox","UTMtoLL","decode","toUpperCase","lat","lon","left","bottom","right","top","ll","accuracy","utm","seasting","easting","snorthing","northing","zoneNumber","zoneLetter","setParm","get100kSetForZone","setColumn","floor","setRow","column","row","parm","index","colOrigin","charCodeAt","rowOrigin","colInt","rowInt","rollover","String","fromCharCode","encode","N","T","C","M","LongOriginRad","ZoneNumber","Lat","Long","LatRad","degToRad","LongRad","tan","UTMEasting","UTMNorthing","round","getLetterDesignator","LLtoUTM","deg","radToDeg","rad","N1","T1","C1","R1","D","LongOrigin","mu","phi1Rad","e1","pow","result","topRight","LetterDesignator","mgrsString","testChar","hunK","sb","substring","set","east100k","curCol","eastingValue","rewindMarker","getEastingFromChar","north100k","curRow","northingValue","getNorthingFromChar","getMinNorthing","remainder","accuracyBonus","sepEastingString","sepNorthingString","sep","sepEasting","sepNorthing","Point","warn","fromMGRS","mgrsStr","toMGRS","defaultDatum","Proj","common","version"],"mappings":"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"}