{"version":3,"file":"index-4146d191.js","sources":["../../../proj4js/lib/constants/values.js","../../../proj4js/lib/constants/PrimeMeridian.js","../../../proj4js/lib/constants/units.js","../../../proj4js/lib/match.js","../../../proj4js/lib/projString.js","../../../proj4js/node_modules/wkt-parser/parser.js","../../../proj4js/node_modules/wkt-parser/process.js","../../../proj4js/node_modules/wkt-parser/index.js","../../../proj4js/lib/defs.js","../../../proj4js/lib/global.js","../../../proj4js/lib/parseCode.js","../../../proj4js/lib/extend.js","../../../proj4js/lib/common/msfnz.js","../../../proj4js/lib/common/sign.js","../../../proj4js/lib/common/adjust_lon.js","../../../proj4js/lib/common/tsfnz.js","../../../proj4js/lib/common/phi2z.js","../../../proj4js/lib/projections/longlat.js","../../../proj4js/lib/projections.js","../../../proj4js/lib/projections/merc.js","../../../proj4js/lib/constants/Ellipsoid.js","../../../proj4js/lib/constants/Datum.js","../../../proj4js/lib/Proj.js","../../../proj4js/lib/deriveConstants.js","../../../proj4js/lib/datum.js","../../../proj4js/lib/datum_transform.js","../../../proj4js/lib/datumUtils.js","../../../proj4js/lib/adjust_axis.js","../../../proj4js/lib/common/toPoint.js","../../../proj4js/lib/checkSanity.js","../../../proj4js/lib/transform.js","../../../proj4js/lib/core.js","../../../proj4js/node_modules/mgrs/mgrs.js","../../../proj4js/lib/Point.js","../../../proj4js/lib/index.js"],"sourcesContent":["export var PJD_3PARAM = 1;\nexport var PJD_7PARAM = 2;\nexport var PJD_WGS84 = 4; // WGS84 or equivalent\nexport var PJD_NODATUM = 5; // WGS84 or equivalent\nexport var SEC_TO_RAD = 4.84813681109535993589914102357e-6;\nexport var HALF_PI = Math.PI/2;\n// ellipoid pj_set_ell.c\nexport var SIXTH = 0.1666666666666666667;\n/* 1/6 */\nexport var RA4 = 0.04722222222222222222;\n/* 17/360 */\nexport var RA6 = 0.02215608465608465608;\nexport var EPSLN = 1.0e-10;\n// you'd think you could use Number.EPSILON above but that makes\n// Mollweide get into an infinate loop.\n\nexport var D2R = 0.01745329251994329577;\nexport var R2D = 57.29577951308232088;\nexport var FORTPI = Math.PI/4;\nexport var TWO_PI = Math.PI * 2;\n// SPI is slightly greater than Math.PI, so values that exceed the -180..180\n// degree range by a tiny amount don't get wrapped. This prevents points that\n// have drifted from their original location along the 180th meridian (due to\n// floating point error) from changing their sign.\nexport var SPI = 3.14159265359;\n","var exports = {};\nexport {exports as default};\n\nexports.greenwich = 0.0; //\"0dE\",\nexports.lisbon = -9.131906111111; //\"9d07'54.862\\\"W\",\nexports.paris = 2.337229166667; //\"2d20'14.025\\\"E\",\nexports.bogota = -74.080916666667; //\"74d04'51.3\\\"W\",\nexports.madrid = -3.687938888889; //\"3d41'16.58\\\"W\",\nexports.rome = 12.452333333333; //\"12d27'8.4\\\"E\",\nexports.bern = 7.439583333333; //\"7d26'22.5\\\"E\",\nexports.jakarta = 106.807719444444; //\"106d48'27.79\\\"E\",\nexports.ferro = -17.666666666667; //\"17d40'W\",\nexports.brussels = 4.367975; //\"4d22'4.71\\\"E\",\nexports.stockholm = 18.058277777778; //\"18d3'29.8\\\"E\",\nexports.athens = 23.7163375; //\"23d42'58.815\\\"E\",\nexports.oslo = 10.722916666667; //\"10d43'22.5\\\"E\"\n","export default {\n  ft: {to_meter: 0.3048},\n  'us-ft': {to_meter: 1200 / 3937}\n};\n","var ignoredChar = /[\\s_\\-\\/\\(\\)]/g;\nexport default function match(obj, key) {\n  if (obj[key]) {\n    return obj[key];\n  }\n  var keys = Object.keys(obj);\n  var lkey = key.toLowerCase().replace(ignoredChar, '');\n  var i = -1;\n  var testkey, processedKey;\n  while (++i < keys.length) {\n    testkey = keys[i];\n    processedKey = testkey.toLowerCase().replace(ignoredChar, '');\n    if (processedKey === lkey) {\n      return obj[testkey];\n    }\n  }\n}\n","import {D2R} from './constants/values';\nimport PrimeMeridian from './constants/PrimeMeridian';\nimport units from './constants/units';\nimport match from './match';\n\nexport default function(defData) {\n  var self = {};\n  var paramObj = defData.split('+').map(function(v) {\n    return v.trim();\n  }).filter(function(a) {\n    return a;\n  }).reduce(function(p, a) {\n    var split = a.split('=');\n    split.push(true);\n    p[split[0].toLowerCase()] = split[1];\n    return p;\n  }, {});\n  var paramName, paramVal, paramOutname;\n  var params = {\n    proj: 'projName',\n    datum: 'datumCode',\n    rf: function(v) {\n      self.rf = parseFloat(v);\n    },\n    lat_0: function(v) {\n      self.lat0 = v * D2R;\n    },\n    lat_1: function(v) {\n      self.lat1 = v * D2R;\n    },\n    lat_2: function(v) {\n      self.lat2 = v * D2R;\n    },\n    lat_ts: function(v) {\n      self.lat_ts = v * D2R;\n    },\n    lon_0: function(v) {\n      self.long0 = v * D2R;\n    },\n    lon_1: function(v) {\n      self.long1 = v * D2R;\n    },\n    lon_2: function(v) {\n      self.long2 = v * D2R;\n    },\n    alpha: function(v) {\n      self.alpha = parseFloat(v) * D2R;\n    },\n    lonc: function(v) {\n      self.longc = v * D2R;\n    },\n    x_0: function(v) {\n      self.x0 = parseFloat(v);\n    },\n    y_0: function(v) {\n      self.y0 = parseFloat(v);\n    },\n    k_0: function(v) {\n      self.k0 = parseFloat(v);\n    },\n    k: function(v) {\n      self.k0 = parseFloat(v);\n    },\n    a: function(v) {\n      self.a = parseFloat(v);\n    },\n    b: function(v) {\n      self.b = parseFloat(v);\n    },\n    r_a: function() {\n      self.R_A = true;\n    },\n    zone: function(v) {\n      self.zone = parseInt(v, 10);\n    },\n    south: function() {\n      self.utmSouth = true;\n    },\n    towgs84: function(v) {\n      self.datum_params = v.split(\",\").map(function(a) {\n        return parseFloat(a);\n      });\n    },\n    to_meter: function(v) {\n      self.to_meter = parseFloat(v);\n    },\n    units: function(v) {\n      self.units = v;\n      var unit = match(units, v);\n      if (unit) {\n        self.to_meter = unit.to_meter;\n      }\n    },\n    from_greenwich: function(v) {\n      self.from_greenwich = v * D2R;\n    },\n    pm: function(v) {\n      var pm = match(PrimeMeridian, v);\n      self.from_greenwich = (pm ? pm : parseFloat(v)) * D2R;\n    },\n    nadgrids: function(v) {\n      if (v === '@null') {\n        self.datumCode = 'none';\n      }\n      else {\n        self.nadgrids = v;\n      }\n    },\n    axis: function(v) {\n      var legalAxis = \"ewnsud\";\n      if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {\n        self.axis = v;\n      }\n    }\n  };\n  for (paramName in paramObj) {\n    paramVal = paramObj[paramName];\n    if (paramName in params) {\n      paramOutname = params[paramName];\n      if (typeof paramOutname === 'function') {\n        paramOutname(paramVal);\n      }\n      else {\n        self[paramOutname] = paramVal;\n      }\n    }\n    else {\n      self[paramName] = paramVal;\n    }\n  }\n  if(typeof self.datumCode === 'string' && self.datumCode !== \"WGS84\"){\n    self.datumCode = self.datumCode.toLowerCase();\n  }\n  return self;\n}\n","export default parseString;\n\nvar NEUTRAL = 1;\nvar KEYWORD = 2;\nvar NUMBER = 3;\nvar QUOTED = 4;\nvar AFTERQUOTE = 5;\nvar ENDED = -1;\nvar whitespace = /\\s/;\nvar latin = /[A-Za-z]/;\nvar keyword = /[A-Za-z84]/;\nvar endThings = /[,\\]]/;\nvar digets = /[\\d\\.E\\-\\+]/;\n// const ignoredChar = /[\\s_\\-\\/\\(\\)]/g;\nfunction Parser(text) {\n  if (typeof text !== 'string') {\n    throw new Error('not a string');\n  }\n  this.text = text.trim();\n  this.level = 0;\n  this.place = 0;\n  this.root = null;\n  this.stack = [];\n  this.currentObject = null;\n  this.state = NEUTRAL;\n}\nParser.prototype.readCharicter = function() {\n  var char = this.text[this.place++];\n  if (this.state !== QUOTED) {\n    while (whitespace.test(char)) {\n      if (this.place >= this.text.length) {\n        return;\n      }\n      char = this.text[this.place++];\n    }\n  }\n  switch (this.state) {\n    case NEUTRAL:\n      return this.neutral(char);\n    case KEYWORD:\n      return this.keyword(char)\n    case QUOTED:\n      return this.quoted(char);\n    case AFTERQUOTE:\n      return this.afterquote(char);\n    case NUMBER:\n      return this.number(char);\n    case ENDED:\n      return;\n  }\n};\nParser.prototype.afterquote = function(char) {\n  if (char === '\"') {\n    this.word += '\"';\n    this.state = QUOTED;\n    return;\n  }\n  if (endThings.test(char)) {\n    this.word = this.word.trim();\n    this.afterItem(char);\n    return;\n  }\n  throw new Error('havn\\'t handled \"' +char + '\" in afterquote yet, index ' + this.place);\n};\nParser.prototype.afterItem = function(char) {\n  if (char === ',') {\n    if (this.word !== null) {\n      this.currentObject.push(this.word);\n    }\n    this.word = null;\n    this.state = NEUTRAL;\n    return;\n  }\n  if (char === ']') {\n    this.level--;\n    if (this.word !== null) {\n      this.currentObject.push(this.word);\n      this.word = null;\n    }\n    this.state = NEUTRAL;\n    this.currentObject = this.stack.pop();\n    if (!this.currentObject) {\n      this.state = ENDED;\n    }\n\n    return;\n  }\n};\nParser.prototype.number = function(char) {\n  if (digets.test(char)) {\n    this.word += char;\n    return;\n  }\n  if (endThings.test(char)) {\n    this.word = parseFloat(this.word);\n    this.afterItem(char);\n    return;\n  }\n  throw new Error('havn\\'t handled \"' +char + '\" in number yet, index ' + this.place);\n};\nParser.prototype.quoted = function(char) {\n  if (char === '\"') {\n    this.state = AFTERQUOTE;\n    return;\n  }\n  this.word += char;\n  return;\n};\nParser.prototype.keyword = function(char) {\n  if (keyword.test(char)) {\n    this.word += char;\n    return;\n  }\n  if (char === '[') {\n    var newObjects = [];\n    newObjects.push(this.word);\n    this.level++;\n    if (this.root === null) {\n      this.root = newObjects;\n    } else {\n      this.currentObject.push(newObjects);\n    }\n    this.stack.push(this.currentObject);\n    this.currentObject = newObjects;\n    this.state = NEUTRAL;\n    return;\n  }\n  if (endThings.test(char)) {\n    this.afterItem(char);\n    return;\n  }\n  throw new Error('havn\\'t handled \"' +char + '\" in keyword yet, index ' + this.place);\n};\nParser.prototype.neutral = function(char) {\n  if (latin.test(char)) {\n    this.word = char;\n    this.state = KEYWORD;\n    return;\n  }\n  if (char === '\"') {\n    this.word = '';\n    this.state = QUOTED;\n    return;\n  }\n  if (digets.test(char)) {\n    this.word = char;\n    this.state = NUMBER;\n    return;\n  }\n  if (endThings.test(char)) {\n    this.afterItem(char);\n    return;\n  }\n  throw new Error('havn\\'t handled \"' +char + '\" in neutral yet, index ' + this.place);\n};\nParser.prototype.output = function() {\n  while (this.place < this.text.length) {\n    this.readCharicter();\n  }\n  if (this.state === ENDED) {\n    return this.root;\n  }\n  throw new Error('unable to parse string \"' +this.text + '\". State is ' + this.state);\n};\n\nfunction parseString(txt) {\n  var parser = new Parser(txt);\n  return parser.output();\n}\n","\n\nfunction mapit(obj, key, value) {\n  if (Array.isArray(key)) {\n    value.unshift(key);\n    key = null;\n  }\n  var thing = key ? {} : obj;\n\n  var out = value.reduce(function(newObj, item) {\n    sExpr(item, newObj);\n    return newObj\n  }, thing);\n  if (key) {\n    obj[key] = out;\n  }\n}\n\nexport function sExpr(v, obj) {\n  if (!Array.isArray(v)) {\n    obj[v] = true;\n    return;\n  }\n  var key = v.shift();\n  if (key === 'PARAMETER') {\n    key = v.shift();\n  }\n  if (v.length === 1) {\n    if (Array.isArray(v[0])) {\n      obj[key] = {};\n      sExpr(v[0], obj[key]);\n      return;\n    }\n    obj[key] = v[0];\n    return;\n  }\n  if (!v.length) {\n    obj[key] = true;\n    return;\n  }\n  if (key === 'TOWGS84') {\n    obj[key] = v;\n    return;\n  }\n  if (key === 'AXIS') {\n    if (!(key in obj)) {\n      obj[key] = [];\n    }\n    obj[key].push(v);\n    return;\n  }\n  if (!Array.isArray(key)) {\n    obj[key] = {};\n  }\n\n  var i;\n  switch (key) {\n    case 'UNIT':\n    case 'PRIMEM':\n    case 'VERT_DATUM':\n      obj[key] = {\n        name: v[0].toLowerCase(),\n        convert: v[1]\n      };\n      if (v.length === 3) {\n        sExpr(v[2], obj[key]);\n      }\n      return;\n    case 'SPHEROID':\n    case 'ELLIPSOID':\n      obj[key] = {\n        name: v[0],\n        a: v[1],\n        rf: v[2]\n      };\n      if (v.length === 4) {\n        sExpr(v[3], obj[key]);\n      }\n      return;\n    case 'PROJECTEDCRS':\n    case 'PROJCRS':\n    case 'GEOGCS':\n    case 'GEOCCS':\n    case 'PROJCS':\n    case 'LOCAL_CS':\n    case 'GEODCRS':\n    case 'GEODETICCRS':\n    case 'GEODETICDATUM':\n    case 'EDATUM':\n    case 'ENGINEERINGDATUM':\n    case 'VERT_CS':\n    case 'VERTCRS':\n    case 'VERTICALCRS':\n    case 'COMPD_CS':\n    case 'COMPOUNDCRS':\n    case 'ENGINEERINGCRS':\n    case 'ENGCRS':\n    case 'FITTED_CS':\n    case 'LOCAL_DATUM':\n    case 'DATUM':\n      v[0] = ['name', v[0]];\n      mapit(obj, key, v);\n      return;\n    default:\n      i = -1;\n      while (++i < v.length) {\n        if (!Array.isArray(v[i])) {\n          return sExpr(v, obj[key]);\n        }\n      }\n      return mapit(obj, key, v);\n  }\n}\n","var D2R = 0.01745329251994329577;\nimport parser from './parser';\nimport {sExpr} from './process';\n\n\n\nfunction rename(obj, params) {\n  var outName = params[0];\n  var inName = params[1];\n  if (!(outName in obj) && (inName in obj)) {\n    obj[outName] = obj[inName];\n    if (params.length === 3) {\n      obj[outName] = params[2](obj[outName]);\n    }\n  }\n}\n\nfunction d2r(input) {\n  return input * D2R;\n}\n\nfunction cleanWKT(wkt) {\n  if (wkt.type === 'GEOGCS') {\n    wkt.projName = 'longlat';\n  } else if (wkt.type === 'LOCAL_CS') {\n    wkt.projName = 'identity';\n    wkt.local = true;\n  } else {\n    if (typeof wkt.PROJECTION === 'object') {\n      wkt.projName = Object.keys(wkt.PROJECTION)[0];\n    } else {\n      wkt.projName = wkt.PROJECTION;\n    }\n  }\n  if (wkt.AXIS) {\n    var axisOrder = '';\n    for (var i = 0, ii = wkt.AXIS.length; i < ii; ++i) {\n      var axis = wkt.AXIS[i];\n      var descriptor = axis[0].toLowerCase();\n      if (descriptor.indexOf('north') !== -1) {\n        axisOrder += 'n';\n      } else if (descriptor.indexOf('south') !== -1) {\n        axisOrder += 's';\n      } else if (descriptor.indexOf('east') !== -1) {\n        axisOrder += 'e';\n      } else if (descriptor.indexOf('west') !== -1) {\n        axisOrder += 'w';\n      }\n    }\n    if (axisOrder.length === 2) {\n      axisOrder += 'u';\n    }\n    if (axisOrder.length === 3) {\n      wkt.axis = axisOrder;\n    }\n  }\n  if (wkt.UNIT) {\n    wkt.units = wkt.UNIT.name.toLowerCase();\n    if (wkt.units === 'metre') {\n      wkt.units = 'meter';\n    }\n    if (wkt.UNIT.convert) {\n      if (wkt.type === 'GEOGCS') {\n        if (wkt.DATUM && wkt.DATUM.SPHEROID) {\n          wkt.to_meter = wkt.UNIT.convert*wkt.DATUM.SPHEROID.a;\n        }\n      } else {\n        wkt.to_meter = wkt.UNIT.convert;\n      }\n    }\n  }\n  var geogcs = wkt.GEOGCS;\n  if (wkt.type === 'GEOGCS') {\n    geogcs = wkt;\n  }\n  if (geogcs) {\n    //if(wkt.GEOGCS.PRIMEM&&wkt.GEOGCS.PRIMEM.convert){\n    //  wkt.from_greenwich=wkt.GEOGCS.PRIMEM.convert*D2R;\n    //}\n    if (geogcs.DATUM) {\n      wkt.datumCode = geogcs.DATUM.name.toLowerCase();\n    } else {\n      wkt.datumCode = geogcs.name.toLowerCase();\n    }\n    if (wkt.datumCode.slice(0, 2) === 'd_') {\n      wkt.datumCode = wkt.datumCode.slice(2);\n    }\n    if (wkt.datumCode === 'new_zealand_geodetic_datum_1949' || wkt.datumCode === 'new_zealand_1949') {\n      wkt.datumCode = 'nzgd49';\n    }\n    if (wkt.datumCode === 'wgs_1984' || wkt.datumCode === 'world_geodetic_system_1984') {\n      if (wkt.PROJECTION === 'Mercator_Auxiliary_Sphere') {\n        wkt.sphere = true;\n      }\n      wkt.datumCode = 'wgs84';\n    }\n    if (wkt.datumCode.slice(-6) === '_ferro') {\n      wkt.datumCode = wkt.datumCode.slice(0, - 6);\n    }\n    if (wkt.datumCode.slice(-8) === '_jakarta') {\n      wkt.datumCode = wkt.datumCode.slice(0, - 8);\n    }\n    if (~wkt.datumCode.indexOf('belge')) {\n      wkt.datumCode = 'rnb72';\n    }\n    if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {\n      wkt.ellps = geogcs.DATUM.SPHEROID.name.replace('_19', '').replace(/[Cc]larke\\_18/, 'clrk');\n      if (wkt.ellps.toLowerCase().slice(0, 13) === 'international') {\n        wkt.ellps = 'intl';\n      }\n\n      wkt.a = geogcs.DATUM.SPHEROID.a;\n      wkt.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);\n    }\n\n    if (geogcs.DATUM && geogcs.DATUM.TOWGS84) {\n      wkt.datum_params = geogcs.DATUM.TOWGS84;\n    }\n    if (~wkt.datumCode.indexOf('osgb_1936')) {\n      wkt.datumCode = 'osgb36';\n    }\n    if (~wkt.datumCode.indexOf('osni_1952')) {\n      wkt.datumCode = 'osni52';\n    }\n    if (~wkt.datumCode.indexOf('tm65')\n      || ~wkt.datumCode.indexOf('geodetic_datum_of_1965')) {\n      wkt.datumCode = 'ire65';\n    }\n    if (wkt.datumCode === 'ch1903+') {\n      wkt.datumCode = 'ch1903';\n    }\n    if (~wkt.datumCode.indexOf('israel')) {\n      wkt.datumCode = 'isr93';\n    }\n  }\n  if (wkt.b && !isFinite(wkt.b)) {\n    wkt.b = wkt.a;\n  }\n\n  function toMeter(input) {\n    var ratio = wkt.to_meter || 1;\n    return input * ratio;\n  }\n  var renamer = function(a) {\n    return rename(wkt, a);\n  };\n  var list = [\n    ['standard_parallel_1', 'Standard_Parallel_1'],\n    ['standard_parallel_2', 'Standard_Parallel_2'],\n    ['false_easting', 'False_Easting'],\n    ['false_northing', 'False_Northing'],\n    ['central_meridian', 'Central_Meridian'],\n    ['latitude_of_origin', 'Latitude_Of_Origin'],\n    ['latitude_of_origin', 'Central_Parallel'],\n    ['scale_factor', 'Scale_Factor'],\n    ['k0', 'scale_factor'],\n    ['latitude_of_center', 'Latitude_Of_Center'],\n    ['latitude_of_center', 'Latitude_of_center'],\n    ['lat0', 'latitude_of_center', d2r],\n    ['longitude_of_center', 'Longitude_Of_Center'],\n    ['longitude_of_center', 'Longitude_of_center'],\n    ['longc', 'longitude_of_center', d2r],\n    ['x0', 'false_easting', toMeter],\n    ['y0', 'false_northing', toMeter],\n    ['long0', 'central_meridian', d2r],\n    ['lat0', 'latitude_of_origin', d2r],\n    ['lat0', 'standard_parallel_1', d2r],\n    ['lat1', 'standard_parallel_1', d2r],\n    ['lat2', 'standard_parallel_2', d2r],\n    ['azimuth', 'Azimuth'],\n    ['alpha', 'azimuth', d2r],\n    ['srsCode', 'name']\n  ];\n  list.forEach(renamer);\n  if (!wkt.long0 && wkt.longc && (wkt.projName === 'Albers_Conic_Equal_Area' || wkt.projName === 'Lambert_Azimuthal_Equal_Area')) {\n    wkt.long0 = wkt.longc;\n  }\n  if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === 'Stereographic_South_Pole' || wkt.projName === 'Polar Stereographic (variant B)')) {\n    wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);\n    wkt.lat_ts = wkt.lat1;\n  }\n}\nexport default function(wkt) {\n  var lisp = parser(wkt);\n  var type = lisp.shift();\n  var name = lisp.shift();\n  lisp.unshift(['name', name]);\n  lisp.unshift(['type', type]);\n  var obj = {};\n  sExpr(lisp, obj);\n  cleanWKT(obj);\n  return obj;\n}\n","import globals from './global';\nimport parseProj from './projString';\nimport wkt from 'wkt-parser';\n\nfunction defs(name) {\n  /*global console*/\n  var that = this;\n  if (arguments.length === 2) {\n    var def = arguments[1];\n    if (typeof def === 'string') {\n      if (def.charAt(0) === '+') {\n        defs[name] = parseProj(arguments[1]);\n      }\n      else {\n        defs[name] = wkt(arguments[1]);\n      }\n    } else {\n      defs[name] = def;\n    }\n  }\n  else if (arguments.length === 1) {\n    if (Array.isArray(name)) {\n      return name.map(function(v) {\n        if (Array.isArray(v)) {\n          defs.apply(that, v);\n        }\n        else {\n          defs(v);\n        }\n      });\n    }\n    else if (typeof name === 'string') {\n      if (name in defs) {\n        return defs[name];\n      }\n    }\n    else if ('EPSG' in name) {\n      defs['EPSG:' + name.EPSG] = name;\n    }\n    else if ('ESRI' in name) {\n      defs['ESRI:' + name.ESRI] = name;\n    }\n    else if ('IAU2000' in name) {\n      defs['IAU2000:' + name.IAU2000] = name;\n    }\n    else {\n      console.log(name);\n    }\n    return;\n  }\n\n\n}\nglobals(defs);\nexport default defs;\n","export default function(defs) {\n  defs('EPSG:4326', \"+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees\");\n  defs('EPSG:4269', \"+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees\");\n  defs('EPSG:3857', \"+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs\");\n\n  defs.WGS84 = defs['EPSG:4326'];\n  defs['EPSG:3785'] = defs['EPSG:3857']; // maintain backward compat, official code is 3857\n  defs.GOOGLE = defs['EPSG:3857'];\n  defs['EPSG:900913'] = defs['EPSG:3857'];\n  defs['EPSG:102113'] = defs['EPSG:3857'];\n}\n","import defs from './defs';\nimport wkt from 'wkt-parser';\nimport projStr from './projString';\nimport match from './match';\nfunction testObj(code){\n  return typeof code === 'string';\n}\nfunction testDef(code){\n  return code in defs;\n}\n var codeWords = ['PROJECTEDCRS', 'PROJCRS', 'GEOGCS','GEOCCS','PROJCS','LOCAL_CS', 'GEODCRS', 'GEODETICCRS', 'GEODETICDATUM', 'ENGCRS', 'ENGINEERINGCRS'];\nfunction testWKT(code){\n  return codeWords.some(function (word) {\n    return code.indexOf(word) > -1;\n  });\n}\nvar codes = ['3857', '900913', '3785', '102113'];\nfunction checkMercator(item) {\n  var auth = match(item, 'authority');\n  if (!auth) {\n    return;\n  }\n  var code = match(auth, 'epsg');\n  return code && codes.indexOf(code) > -1;\n}\nfunction checkProjStr(item) {\n  var ext = match(item, 'extension');\n  if (!ext) {\n    return;\n  }\n  return match(ext, 'proj4');\n}\nfunction testProj(code){\n  return code[0] === '+';\n}\nfunction parse(code){\n  if (testObj(code)) {\n    //check to see if this is a WKT string\n    if (testDef(code)) {\n      return defs[code];\n    }\n    if (testWKT(code)) {\n      var out = wkt(code);\n      // test of spetial case, due to this being a very common and often malformed\n      if (checkMercator(out)) {\n        return defs['EPSG:3857'];\n      }\n      var maybeProjStr = checkProjStr(out);\n      if (maybeProjStr) {\n        return projStr(maybeProjStr);\n      }\n      return out;\n    }\n    if (testProj(code)) {\n      return projStr(code);\n    }\n  }else{\n    return code;\n  }\n}\n\nexport default parse;\n","export default function(destination, source) {\n  destination = destination || {};\n  var value, property;\n  if (!source) {\n    return destination;\n  }\n  for (property in source) {\n    value = source[property];\n    if (value !== undefined) {\n      destination[property] = value;\n    }\n  }\n  return destination;\n}\n","export default function(eccent, sinphi, cosphi) {\n  var con = eccent * sinphi;\n  return cosphi / (Math.sqrt(1 - con * con));\n}","export default function(x) {\n  return x<0 ? -1 : 1;\n}","\nimport {TWO_PI, SPI} from '../constants/values';\nimport sign from './sign';\n\nexport default function(x) {\n  return (Math.abs(x) <= SPI) ? x : (x - (sign(x) * TWO_PI));\n}\n","import {HALF_PI} from '../constants/values';\n\nexport default function(eccent, phi, sinphi) {\n  var con = eccent * sinphi;\n  var com = 0.5 * eccent;\n  con = Math.pow(((1 - con) / (1 + con)), com);\n  return (Math.tan(0.5 * (HALF_PI - phi)) / con);\n}\n","import {HALF_PI} from '../constants/values';\n\nexport default function(eccent, ts) {\n  var eccnth = 0.5 * eccent;\n  var con, dphi;\n  var phi = HALF_PI - 2 * Math.atan(ts);\n  for (var i = 0; i <= 15; i++) {\n    con = eccent * Math.sin(phi);\n    dphi = HALF_PI - 2 * Math.atan(ts * (Math.pow(((1 - con) / (1 + con)), eccnth))) - phi;\n    phi += dphi;\n    if (Math.abs(dphi) <= 0.0000000001) {\n      return phi;\n    }\n  }\n  //console.log(\"phi2z has NoConvergence\");\n  return -9999;\n}\n","export function init() {\n  //no-op for longlat\n}\n\nfunction identity(pt) {\n  return pt;\n}\nexport {identity as forward};\nexport {identity as inverse};\nexport var names = [\"longlat\", \"identity\"];\nexport default {\n  init: init,\n  forward: identity,\n  inverse: identity,\n  names: names\n};\n","import merc from \"./projections/merc\";\nimport longlat from \"./projections/longlat\";\nvar projs = [merc, longlat];\nvar names = {};\nvar projStore = [];\n\nfunction add(proj, i) {\n  var len = projStore.length;\n  if (!proj.names) {\n    console.log(i);\n    return true;\n  }\n  projStore[len] = proj;\n  proj.names.forEach(function(n) {\n    names[n.toLowerCase()] = len;\n  });\n  return this;\n}\n\nexport {add};\n\nexport function get(name) {\n  if (!name) {\n    return false;\n  }\n  var n = name.toLowerCase();\n  if (typeof names[n] !== 'undefined' && projStore[names[n]]) {\n    return projStore[names[n]];\n  }\n}\n\nexport function start() {\n  projs.forEach(add);\n}\nexport default {\n  start: start,\n  add: add,\n  get: get\n};\n","import msfnz from '../common/msfnz';\n\nimport adjust_lon from '../common/adjust_lon';\nimport tsfnz from '../common/tsfnz';\nimport phi2z from '../common/phi2z';\nimport {FORTPI, R2D, EPSLN, HALF_PI} from '../constants/values';\nexport function init() {\n  var con = this.b / this.a;\n  this.es = 1 - con * con;\n  if(!('x0' in this)){\n    this.x0 = 0;\n  }\n  if(!('y0' in this)){\n    this.y0 = 0;\n  }\n  this.e = Math.sqrt(this.es);\n  if (this.lat_ts) {\n    if (this.sphere) {\n      this.k0 = Math.cos(this.lat_ts);\n    }\n    else {\n      this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));\n    }\n  }\n  else {\n    if (!this.k0) {\n      if (this.k) {\n        this.k0 = this.k;\n      }\n      else {\n        this.k0 = 1;\n      }\n    }\n  }\n}\n\n/* Mercator forward equations--mapping lat,long to x,y\n  --------------------------------------------------*/\n\nexport function forward(p) {\n  var lon = p.x;\n  var lat = p.y;\n  // convert to radians\n  if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {\n    return null;\n  }\n\n  var x, y;\n  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {\n    return null;\n  }\n  else {\n    if (this.sphere) {\n      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);\n      y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));\n    }\n    else {\n      var sinphi = Math.sin(lat);\n      var ts = tsfnz(this.e, lat, sinphi);\n      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);\n      y = this.y0 - this.a * this.k0 * Math.log(ts);\n    }\n    p.x = x;\n    p.y = y;\n    return p;\n  }\n}\n\n/* Mercator inverse equations--mapping x,y to lat/long\n  --------------------------------------------------*/\nexport function inverse(p) {\n\n  var x = p.x - this.x0;\n  var y = p.y - this.y0;\n  var lon, lat;\n\n  if (this.sphere) {\n    lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));\n  }\n  else {\n    var ts = Math.exp(-y / (this.a * this.k0));\n    lat = phi2z(this.e, ts);\n    if (lat === -9999) {\n      return null;\n    }\n  }\n  lon = adjust_lon(this.long0 + x / (this.a * this.k0));\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nexport var names = [\"Mercator\", \"Popular Visualisation Pseudo Mercator\", \"Mercator_1SP\", \"Mercator_Auxiliary_Sphere\", \"merc\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n","var exports = {};\nexport {exports as default};\nexports.MERIT = {\n  a: 6378137.0,\n  rf: 298.257,\n  ellipseName: \"MERIT 1983\"\n};\n\nexports.SGS85 = {\n  a: 6378136.0,\n  rf: 298.257,\n  ellipseName: \"Soviet Geodetic System 85\"\n};\n\nexports.GRS80 = {\n  a: 6378137.0,\n  rf: 298.257222101,\n  ellipseName: \"GRS 1980(IUGG, 1980)\"\n};\n\nexports.IAU76 = {\n  a: 6378140.0,\n  rf: 298.257,\n  ellipseName: \"IAU 1976\"\n};\n\nexports.airy = {\n  a: 6377563.396,\n  b: 6356256.910,\n  ellipseName: \"Airy 1830\"\n};\n\nexports.APL4 = {\n  a: 6378137,\n  rf: 298.25,\n  ellipseName: \"Appl. Physics. 1965\"\n};\n\nexports.NWL9D = {\n  a: 6378145.0,\n  rf: 298.25,\n  ellipseName: \"Naval Weapons Lab., 1965\"\n};\n\nexports.mod_airy = {\n  a: 6377340.189,\n  b: 6356034.446,\n  ellipseName: \"Modified Airy\"\n};\n\nexports.andrae = {\n  a: 6377104.43,\n  rf: 300.0,\n  ellipseName: \"Andrae 1876 (Den., Iclnd.)\"\n};\n\nexports.aust_SA = {\n  a: 6378160.0,\n  rf: 298.25,\n  ellipseName: \"Australian Natl & S. Amer. 1969\"\n};\n\nexports.GRS67 = {\n  a: 6378160.0,\n  rf: 298.2471674270,\n  ellipseName: \"GRS 67(IUGG 1967)\"\n};\n\nexports.bessel = {\n  a: 6377397.155,\n  rf: 299.1528128,\n  ellipseName: \"Bessel 1841\"\n};\n\nexports.bess_nam = {\n  a: 6377483.865,\n  rf: 299.1528128,\n  ellipseName: \"Bessel 1841 (Namibia)\"\n};\n\nexports.clrk66 = {\n  a: 6378206.4,\n  b: 6356583.8,\n  ellipseName: \"Clarke 1866\"\n};\n\nexports.clrk80 = {\n  a: 6378249.145,\n  rf: 293.4663,\n  ellipseName: \"Clarke 1880 mod.\"\n};\n\nexports.clrk58 = {\n  a: 6378293.645208759,\n  rf: 294.2606763692654,\n  ellipseName: \"Clarke 1858\"\n};\n\nexports.CPM = {\n  a: 6375738.7,\n  rf: 334.29,\n  ellipseName: \"Comm. des Poids et Mesures 1799\"\n};\n\nexports.delmbr = {\n  a: 6376428.0,\n  rf: 311.5,\n  ellipseName: \"Delambre 1810 (Belgium)\"\n};\n\nexports.engelis = {\n  a: 6378136.05,\n  rf: 298.2566,\n  ellipseName: \"Engelis 1985\"\n};\n\nexports.evrst30 = {\n  a: 6377276.345,\n  rf: 300.8017,\n  ellipseName: \"Everest 1830\"\n};\n\nexports.evrst48 = {\n  a: 6377304.063,\n  rf: 300.8017,\n  ellipseName: \"Everest 1948\"\n};\n\nexports.evrst56 = {\n  a: 6377301.243,\n  rf: 300.8017,\n  ellipseName: \"Everest 1956\"\n};\n\nexports.evrst69 = {\n  a: 6377295.664,\n  rf: 300.8017,\n  ellipseName: \"Everest 1969\"\n};\n\nexports.evrstSS = {\n  a: 6377298.556,\n  rf: 300.8017,\n  ellipseName: \"Everest (Sabah & Sarawak)\"\n};\n\nexports.fschr60 = {\n  a: 6378166.0,\n  rf: 298.3,\n  ellipseName: \"Fischer (Mercury Datum) 1960\"\n};\n\nexports.fschr60m = {\n  a: 6378155.0,\n  rf: 298.3,\n  ellipseName: \"Fischer 1960\"\n};\n\nexports.fschr68 = {\n  a: 6378150.0,\n  rf: 298.3,\n  ellipseName: \"Fischer 1968\"\n};\n\nexports.helmert = {\n  a: 6378200.0,\n  rf: 298.3,\n  ellipseName: \"Helmert 1906\"\n};\n\nexports.hough = {\n  a: 6378270.0,\n  rf: 297.0,\n  ellipseName: \"Hough\"\n};\n\nexports.intl = {\n  a: 6378388.0,\n  rf: 297.0,\n  ellipseName: \"International 1909 (Hayford)\"\n};\n\nexports.kaula = {\n  a: 6378163.0,\n  rf: 298.24,\n  ellipseName: \"Kaula 1961\"\n};\n\nexports.lerch = {\n  a: 6378139.0,\n  rf: 298.257,\n  ellipseName: \"Lerch 1979\"\n};\n\nexports.mprts = {\n  a: 6397300.0,\n  rf: 191.0,\n  ellipseName: \"Maupertius 1738\"\n};\n\nexports.new_intl = {\n  a: 6378157.5,\n  b: 6356772.2,\n  ellipseName: \"New International 1967\"\n};\n\nexports.plessis = {\n  a: 6376523.0,\n  rf: 6355863.0,\n  ellipseName: \"Plessis 1817 (France)\"\n};\n\nexports.krass = {\n  a: 6378245.0,\n  rf: 298.3,\n  ellipseName: \"Krassovsky, 1942\"\n};\n\nexports.SEasia = {\n  a: 6378155.0,\n  b: 6356773.3205,\n  ellipseName: \"Southeast Asia\"\n};\n\nexports.walbeck = {\n  a: 6376896.0,\n  b: 6355834.8467,\n  ellipseName: \"Walbeck\"\n};\n\nexports.WGS60 = {\n  a: 6378165.0,\n  rf: 298.3,\n  ellipseName: \"WGS 60\"\n};\n\nexports.WGS66 = {\n  a: 6378145.0,\n  rf: 298.25,\n  ellipseName: \"WGS 66\"\n};\n\nexports.WGS7 = {\n  a: 6378135.0,\n  rf: 298.26,\n  ellipseName: \"WGS 72\"\n};\n\nexport var WGS84 = exports.WGS84 = {\n  a: 6378137.0,\n  rf: 298.257223563,\n  ellipseName: \"WGS 84\"\n};\n\nexports.sphere = {\n  a: 6370997.0,\n  b: 6370997.0,\n  ellipseName: \"Normal Sphere (r=6370997)\"\n};\n","var exports = {};\nexport {exports as default};\nexports.wgs84 = {\n  towgs84: \"0,0,0\",\n  ellipse: \"WGS84\",\n  datumName: \"WGS84\"\n};\n\nexports.ch1903 = {\n  towgs84: \"674.374,15.056,405.346\",\n  ellipse: \"bessel\",\n  datumName: \"swiss\"\n};\n\nexports.ggrs87 = {\n  towgs84: \"-199.87,74.79,246.62\",\n  ellipse: \"GRS80\",\n  datumName: \"Greek_Geodetic_Reference_System_1987\"\n};\n\nexports.nad83 = {\n  towgs84: \"0,0,0\",\n  ellipse: \"GRS80\",\n  datumName: \"North_American_Datum_1983\"\n};\n\nexports.nad27 = {\n  nadgrids: \"@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat\",\n  ellipse: \"clrk66\",\n  datumName: \"North_American_Datum_1927\"\n};\n\nexports.potsdam = {\n  towgs84: \"606.0,23.0,413.0\",\n  ellipse: \"bessel\",\n  datumName: \"Potsdam Rauenberg 1950 DHDN\"\n};\n\nexports.carthage = {\n  towgs84: \"-263.0,6.0,431.0\",\n  ellipse: \"clark80\",\n  datumName: \"Carthage 1934 Tunisia\"\n};\n\nexports.hermannskogel = {\n  towgs84: \"653.0,-212.0,449.0\",\n  ellipse: \"bessel\",\n  datumName: \"Hermannskogel\"\n};\n\nexports.osni52 = {\n  towgs84: \"482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15\",\n  ellipse: \"airy\",\n  datumName: \"Irish National\"\n};\n\nexports.ire65 = {\n  towgs84: \"482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15\",\n  ellipse: \"mod_airy\",\n  datumName: \"Ireland 1965\"\n};\n\nexports.rassadiran = {\n  towgs84: \"-133.63,-157.5,-158.62\",\n  ellipse: \"intl\",\n  datumName: \"Rassadiran\"\n};\n\nexports.nzgd49 = {\n  towgs84: \"59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993\",\n  ellipse: \"intl\",\n  datumName: \"New Zealand Geodetic Datum 1949\"\n};\n\nexports.osgb36 = {\n  towgs84: \"446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894\",\n  ellipse: \"airy\",\n  datumName: \"Airy 1830\"\n};\n\nexports.s_jtsk = {\n  towgs84: \"589,76,480\",\n  ellipse: 'bessel',\n  datumName: 'S-JTSK (Ferro)'\n};\n\nexports.beduaram = {\n  towgs84: '-106,-87,188',\n  ellipse: 'clrk80',\n  datumName: 'Beduaram'\n};\n\nexports.gunung_segara = {\n  towgs84: '-403,684,41',\n  ellipse: 'bessel',\n  datumName: 'Gunung Segara Jakarta'\n};\n\nexports.rnb72 = {\n  towgs84: \"106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1\",\n  ellipse: \"intl\",\n  datumName: \"Reseau National Belge 1972\"\n};\n","import parseCode from './parseCode';\nimport extend from './extend';\nimport projections from './projections';\nimport {sphere as dc_sphere, eccentricity as dc_eccentricity} from './deriveConstants';\nimport Datum from './constants/Datum';\nimport datum from './datum';\nimport match from './match';\n\nfunction Projection(srsCode,callback) {\n  if (!(this instanceof Projection)) {\n    return new Projection(srsCode);\n  }\n  callback = callback || function(error){\n    if(error){\n      throw error;\n    }\n  };\n  var json = parseCode(srsCode);\n  if(typeof json !== 'object'){\n    callback(srsCode);\n    return;\n  }\n  var ourProj = Projection.projections.get(json.projName);\n  if(!ourProj){\n    callback(srsCode);\n    return;\n  }\n  if (json.datumCode && json.datumCode !== 'none') {\n    var datumDef = match(Datum, json.datumCode);\n    if (datumDef) {\n      json.datum_params = datumDef.towgs84 ? datumDef.towgs84.split(',') : null;\n      json.ellps = datumDef.ellipse;\n      json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;\n    }\n  }\n  json.k0 = json.k0 || 1.0;\n  json.axis = json.axis || 'enu';\n  json.ellps = json.ellps || 'wgs84';\n  var sphere_ = dc_sphere(json.a, json.b, json.rf, json.ellps, json.sphere);\n  var ecc = dc_eccentricity(sphere_.a, sphere_.b, sphere_.rf, json.R_A);\n  var datumObj = json.datum || datum(json.datumCode, json.datum_params, sphere_.a, sphere_.b, ecc.es, ecc.ep2);\n\n  extend(this, json); // transfer everything over from the projection because we don't know what we'll need\n  extend(this, ourProj); // transfer all the methods from the projection\n\n  // copy the 4 things over we calulated in deriveConstants.sphere\n  this.a = sphere_.a;\n  this.b = sphere_.b;\n  this.rf = sphere_.rf;\n  this.sphere = sphere_.sphere;\n\n  // copy the 3 things we calculated in deriveConstants.eccentricity\n  this.es = ecc.es;\n  this.e = ecc.e;\n  this.ep2 = ecc.ep2;\n\n  // add in the datum object\n  this.datum = datumObj;\n\n  // init the projection\n  this.init();\n\n  // legecy callback from back in the day when it went to spatialreference.org\n  callback(null, this);\n\n}\nProjection.projections = projections;\nProjection.projections.start();\nexport default Projection;\n","import {SIXTH, RA4, RA6, EPSLN} from './constants/values';\nimport {default as Ellipsoid, WGS84} from './constants/Ellipsoid';\nimport match from './match';\n\nexport function eccentricity(a, b, rf, R_A) {\n  var a2 = a * a; // used in geocentric\n  var b2 = b * b; // used in geocentric\n  var es = (a2 - b2) / a2; // e ^ 2\n  var e = 0;\n  if (R_A) {\n    a *= 1 - es * (SIXTH + es * (RA4 + es * RA6));\n    a2 = a * a;\n    es = 0;\n  } else {\n    e = Math.sqrt(es); // eccentricity\n  }\n  var ep2 = (a2 - b2) / b2; // used in geocentric\n  return {\n    es: es,\n    e: e,\n    ep2: ep2\n  };\n}\nexport function sphere(a, b, rf, ellps, sphere) {\n  if (!a) { // do we have an ellipsoid?\n    var ellipse = match(Ellipsoid, ellps);\n    if (!ellipse) {\n      ellipse = WGS84;\n    }\n    a = ellipse.a;\n    b = ellipse.b;\n    rf = ellipse.rf;\n  }\n\n  if (rf && !b) {\n    b = (1.0 - 1.0 / rf) * a;\n  }\n  if (rf === 0 || Math.abs(a - b) < EPSLN) {\n    sphere = true;\n    b = a;\n  }\n  return {\n    a: a,\n    b: b,\n    rf: rf,\n    sphere: sphere\n  };\n}\n","import {PJD_3PARAM, PJD_7PARAM, PJD_WGS84, PJD_NODATUM, SEC_TO_RAD} from './constants/values';\n\nfunction datum(datumCode, datum_params, a, b, es, ep2) {\n  var out = {};\n\n  if (datumCode === undefined || datumCode === 'none') {\n    out.datum_type = PJD_NODATUM;\n  } else {\n    out.datum_type = PJD_WGS84;\n  }\n\n  if (datum_params) {\n    out.datum_params = datum_params.map(parseFloat);\n    if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {\n      out.datum_type = PJD_3PARAM;\n    }\n    if (out.datum_params.length > 3) {\n      if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {\n        out.datum_type = PJD_7PARAM;\n        out.datum_params[3] *= SEC_TO_RAD;\n        out.datum_params[4] *= SEC_TO_RAD;\n        out.datum_params[5] *= SEC_TO_RAD;\n        out.datum_params[6] = (out.datum_params[6] / 1000000.0) + 1.0;\n      }\n    }\n  }\n\n  out.a = a; //datum object also uses these values\n  out.b = b;\n  out.es = es;\n  out.ep2 = ep2;\n  return out;\n}\n\nexport default datum;\n","import {PJD_3PARAM, PJD_7PARAM, PJD_NODATUM} from './constants/values';\n\nimport {geodeticToGeocentric, geocentricToGeodetic, geocentricToWgs84, geocentricFromWgs84, compareDatums} from './datumUtils';\nfunction checkParams(type) {\n  return (type === PJD_3PARAM || type === PJD_7PARAM);\n}\n\nexport default function(source, dest, point) {\n  // Short cut if the datums are identical.\n  if (compareDatums(source, dest)) {\n    return point; // in this case, zero is sucess,\n    // whereas cs_compare_datums returns 1 to indicate TRUE\n    // confusing, should fix this\n  }\n\n  // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest\n  if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {\n    return point;\n  }\n\n  // If this datum requires grid shifts, then apply it to geodetic coordinates.\n\n  // Do we need to go through geocentric coordinates?\n  if (source.es === dest.es && source.a === dest.a && !checkParams(source.datum_type) &&  !checkParams(dest.datum_type)) {\n    return point;\n  }\n\n  // Convert to geocentric coordinates.\n  point = geodeticToGeocentric(point, source.es, source.a);\n  // Convert between datums\n  if (checkParams(source.datum_type)) {\n    point = geocentricToWgs84(point, source.datum_type, source.datum_params);\n  }\n  if (checkParams(dest.datum_type)) {\n    point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);\n  }\n  return geocentricToGeodetic(point, dest.es, dest.a, dest.b);\n\n}\n","'use strict';\nimport {PJD_3PARAM, PJD_7PARAM, HALF_PI} from './constants/values';\nexport function compareDatums(source, dest) {\n  if (source.datum_type !== dest.datum_type) {\n    return false; // false, datums are not equal\n  } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 0.000000000050) {\n    // the tolerance for es is to ensure that GRS80 and WGS84\n    // are considered identical\n    return false;\n  } else if (source.datum_type === PJD_3PARAM) {\n    return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2]);\n  } else if (source.datum_type === PJD_7PARAM) {\n    return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6]);\n  } else {\n    return true; // datums are equal\n  }\n} // cs_compare_datums()\n\n/*\n * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates\n * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),\n * according to the current ellipsoid parameters.\n *\n *    Latitude  : Geodetic latitude in radians                     (input)\n *    Longitude : Geodetic longitude in radians                    (input)\n *    Height    : Geodetic height, in meters                       (input)\n *    X         : Calculated Geocentric X coordinate, in meters    (output)\n *    Y         : Calculated Geocentric Y coordinate, in meters    (output)\n *    Z         : Calculated Geocentric Z coordinate, in meters    (output)\n *\n */\nexport function geodeticToGeocentric(p, es, a) {\n  var Longitude = p.x;\n  var Latitude = p.y;\n  var Height = p.z ? p.z : 0; //Z value not always supplied\n\n  var Rn; /*  Earth radius at location  */\n  var Sin_Lat; /*  Math.sin(Latitude)  */\n  var Sin2_Lat; /*  Square of Math.sin(Latitude)  */\n  var Cos_Lat; /*  Math.cos(Latitude)  */\n\n  /*\n   ** Don't blow up if Latitude is just a little out of the value\n   ** range as it may just be a rounding issue.  Also removed longitude\n   ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.\n   */\n  if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {\n    Latitude = -HALF_PI;\n  } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {\n    Latitude = HALF_PI;\n  } else if (Latitude < -HALF_PI) {\n    /* Latitude out of range */\n    //..reportError('geocent:lat out of range:' + Latitude);\n    return { x: -Infinity, y: -Infinity, z: p.z };\n  } else if (Latitude > HALF_PI) {\n    /* Latitude out of range */\n    return { x: Infinity, y: Infinity, z: p.z };\n  }\n\n  if (Longitude > Math.PI) {\n    Longitude -= (2 * Math.PI);\n  }\n  Sin_Lat = Math.sin(Latitude);\n  Cos_Lat = Math.cos(Latitude);\n  Sin2_Lat = Sin_Lat * Sin_Lat;\n  Rn = a / (Math.sqrt(1.0e0 - es * Sin2_Lat));\n  return {\n    x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),\n    y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),\n    z: ((Rn * (1 - es)) + Height) * Sin_Lat\n  };\n} // cs_geodetic_to_geocentric()\n\nexport function geocentricToGeodetic(p, es, a, b) {\n  /* local defintions and variables */\n  /* end-criterium of loop, accuracy of sin(Latitude) */\n  var genau = 1e-12;\n  var genau2 = (genau * genau);\n  var maxiter = 30;\n\n  var P; /* distance between semi-minor axis and location */\n  var RR; /* distance between center and location */\n  var CT; /* sin of geocentric latitude */\n  var ST; /* cos of geocentric latitude */\n  var RX;\n  var RK;\n  var RN; /* Earth radius at location */\n  var CPHI0; /* cos of start or old geodetic latitude in iterations */\n  var SPHI0; /* sin of start or old geodetic latitude in iterations */\n  var CPHI; /* cos of searched geodetic latitude */\n  var SPHI; /* sin of searched geodetic latitude */\n  var SDPHI; /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */\n  var iter; /* # of continous iteration, max. 30 is always enough (s.a.) */\n\n  var X = p.x;\n  var Y = p.y;\n  var Z = p.z ? p.z : 0.0; //Z value not always supplied\n  var Longitude;\n  var Latitude;\n  var Height;\n\n  P = Math.sqrt(X * X + Y * Y);\n  RR = Math.sqrt(X * X + Y * Y + Z * Z);\n\n  /*      special cases for latitude and longitude */\n  if (P / a < genau) {\n\n    /*  special case, if P=0. (X=0., Y=0.) */\n    Longitude = 0.0;\n\n    /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis\n     *  of ellipsoid (=center of mass), Latitude becomes PI/2 */\n    if (RR / a < genau) {\n      Latitude = HALF_PI;\n      Height = -b;\n      return {\n        x: p.x,\n        y: p.y,\n        z: p.z\n      };\n    }\n  } else {\n    /*  ellipsoidal (geodetic) longitude\n     *  interval: -PI < Longitude <= +PI */\n    Longitude = Math.atan2(Y, X);\n  }\n\n  /* --------------------------------------------------------------\n   * Following iterative algorithm was developped by\n   * \"Institut for Erdmessung\", University of Hannover, July 1988.\n   * Internet: www.ife.uni-hannover.de\n   * Iterative computation of CPHI,SPHI and Height.\n   * Iteration of CPHI and SPHI to 10**-12 radian resp.\n   * 2*10**-7 arcsec.\n   * --------------------------------------------------------------\n   */\n  CT = Z / RR;\n  ST = P / RR;\n  RX = 1.0 / Math.sqrt(1.0 - es * (2.0 - es) * ST * ST);\n  CPHI0 = ST * (1.0 - es) * RX;\n  SPHI0 = CT * RX;\n  iter = 0;\n\n  /* loop to find sin(Latitude) resp. Latitude\n   * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */\n  do {\n    iter++;\n    RN = a / Math.sqrt(1.0 - es * SPHI0 * SPHI0);\n\n    /*  ellipsoidal (geodetic) height */\n    Height = P * CPHI0 + Z * SPHI0 - RN * (1.0 - es * SPHI0 * SPHI0);\n\n    RK = es * RN / (RN + Height);\n    RX = 1.0 / Math.sqrt(1.0 - RK * (2.0 - RK) * ST * ST);\n    CPHI = ST * (1.0 - RK) * RX;\n    SPHI = CT * RX;\n    SDPHI = SPHI * CPHI0 - CPHI * SPHI0;\n    CPHI0 = CPHI;\n    SPHI0 = SPHI;\n  }\n  while (SDPHI * SDPHI > genau2 && iter < maxiter);\n\n  /*      ellipsoidal (geodetic) latitude */\n  Latitude = Math.atan(SPHI / Math.abs(CPHI));\n  return {\n    x: Longitude,\n    y: Latitude,\n    z: Height\n  };\n} // cs_geocentric_to_geodetic()\n\n/****************************************************************/\n// pj_geocentic_to_wgs84( p )\n//  p = point to transform in geocentric coordinates (x,y,z)\n\n\n/** point object, nothing fancy, just allows values to be\n    passed back and forth by reference rather than by value.\n    Other point classes may be used as long as they have\n    x and y properties, which will get modified in the transform method.\n*/\nexport function geocentricToWgs84(p, datum_type, datum_params) {\n\n  if (datum_type === PJD_3PARAM) {\n    // if( x[io] === HUGE_VAL )\n    //    continue;\n    return {\n      x: p.x + datum_params[0],\n      y: p.y + datum_params[1],\n      z: p.z + datum_params[2],\n    };\n  } else if (datum_type === PJD_7PARAM) {\n    var Dx_BF = datum_params[0];\n    var Dy_BF = datum_params[1];\n    var Dz_BF = datum_params[2];\n    var Rx_BF = datum_params[3];\n    var Ry_BF = datum_params[4];\n    var Rz_BF = datum_params[5];\n    var M_BF = datum_params[6];\n    // if( x[io] === HUGE_VAL )\n    //    continue;\n    return {\n      x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,\n      y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,\n      z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF\n    };\n  }\n} // cs_geocentric_to_wgs84\n\n/****************************************************************/\n// pj_geocentic_from_wgs84()\n//  coordinate system definition,\n//  point to transform in geocentric coordinates (x,y,z)\nexport function geocentricFromWgs84(p, datum_type, datum_params) {\n\n  if (datum_type === PJD_3PARAM) {\n    //if( x[io] === HUGE_VAL )\n    //    continue;\n    return {\n      x: p.x - datum_params[0],\n      y: p.y - datum_params[1],\n      z: p.z - datum_params[2],\n    };\n\n  } else if (datum_type === PJD_7PARAM) {\n    var Dx_BF = datum_params[0];\n    var Dy_BF = datum_params[1];\n    var Dz_BF = datum_params[2];\n    var Rx_BF = datum_params[3];\n    var Ry_BF = datum_params[4];\n    var Rz_BF = datum_params[5];\n    var M_BF = datum_params[6];\n    var x_tmp = (p.x - Dx_BF) / M_BF;\n    var y_tmp = (p.y - Dy_BF) / M_BF;\n    var z_tmp = (p.z - Dz_BF) / M_BF;\n    //if( x[io] === HUGE_VAL )\n    //    continue;\n\n    return {\n      x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,\n      y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,\n      z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp\n    };\n  } //cs_geocentric_from_wgs84()\n}\n","export default function(crs, denorm, point) {\n  var xin = point.x,\n    yin = point.y,\n    zin = point.z || 0.0;\n  var v, t, i;\n  var out = {};\n  for (i = 0; i < 3; i++) {\n    if (denorm && i === 2 && point.z === undefined) {\n      continue;\n    }\n    if (i === 0) {\n      v = xin;\n      if (\"ew\".indexOf(crs.axis[i]) !== -1) {\n        t = 'x';\n      } else {\n        t = 'y';\n      }\n\n    }\n    else if (i === 1) {\n      v = yin;\n      if (\"ns\".indexOf(crs.axis[i]) !== -1) {\n        t = 'y';\n      } else {\n        t = 'x';\n      }\n    }\n    else {\n      v = zin;\n      t = 'z';\n    }\n    switch (crs.axis[i]) {\n    case 'e':\n      out[t] = v;\n      break;\n    case 'w':\n      out[t] = -v;\n      break;\n    case 'n':\n      out[t] = v;\n      break;\n    case 's':\n      out[t] = -v;\n      break;\n    case 'u':\n      if (point[t] !== undefined) {\n        out.z = v;\n      }\n      break;\n    case 'd':\n      if (point[t] !== undefined) {\n        out.z = -v;\n      }\n      break;\n    default:\n      //console.log(\"ERROR: unknow axis (\"+crs.axis[i]+\") - check definition of \"+crs.projName);\n      return null;\n    }\n  }\n  return out;\n}\n","export default function (array){\n  var out = {\n    x: array[0],\n    y: array[1]\n  };\n  if (array.length>2) {\n    out.z = array[2];\n  }\n  if (array.length>3) {\n    out.m = array[3];\n  }\n  return out;\n}","export default function (point) {\n  checkCoord(point.x);\n  checkCoord(point.y);\n}\nfunction checkCoord(num) {\n  if (typeof Number.isFinite === 'function') {\n    if (Number.isFinite(num)) {\n      return;\n    }\n    throw new TypeError('coordinates must be finite numbers');\n  }\n  if (typeof num !== 'number' || num !== num || !isFinite(num)) {\n    throw new TypeError('coordinates must be finite numbers');\n  }\n}\n","import {D2R, R2D, PJD_3PARAM, PJD_7PARAM} from './constants/values';\nimport datum_transform from './datum_transform';\nimport adjust_axis from './adjust_axis';\nimport proj from './Proj';\nimport toPoint from './common/toPoint';\nimport checkSanity from './checkSanity';\n\nfunction checkNotWGS(source, dest) {\n  return ((source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM) && dest.datumCode !== 'WGS84') || ((dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM) && source.datumCode !== 'WGS84');\n}\n\nexport default function transform(source, dest, point) {\n  var wgs84;\n  if (Array.isArray(point)) {\n    point = toPoint(point);\n  }\n  checkSanity(point);\n  // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84\n  if (source.datum && dest.datum && checkNotWGS(source, dest)) {\n    wgs84 = new proj('WGS84');\n    point = transform(source, wgs84, point);\n    source = wgs84;\n  }\n  // DGR, 2010/11/12\n  if (source.axis !== 'enu') {\n    point = adjust_axis(source, false, point);\n  }\n  // Transform source points to long/lat, if they aren't already.\n  if (source.projName === 'longlat') {\n    point = {\n      x: point.x * D2R,\n      y: point.y * D2R,\n      z: point.z || 0\n    };\n  } else {\n    if (source.to_meter) {\n      point = {\n        x: point.x * source.to_meter,\n        y: point.y * source.to_meter,\n        z: point.z || 0\n      };\n    }\n    point = source.inverse(point); // Convert Cartesian to longlat\n    if (!point) {\n      return;\n    }\n  }\n  // Adjust for the prime meridian if necessary\n  if (source.from_greenwich) {\n    point.x += source.from_greenwich;\n  }\n\n  // Convert datums if needed, and if possible.\n  point = datum_transform(source.datum, dest.datum, point);\n\n  // Adjust for the prime meridian if necessary\n  if (dest.from_greenwich) {\n    point = {\n      x: point.x - dest.from_greenwich,\n      y: point.y,\n      z: point.z || 0\n    };\n  }\n\n  if (dest.projName === 'longlat') {\n    // convert radians to decimal degrees\n    point = {\n      x: point.x * R2D,\n      y: point.y * R2D,\n      z: point.z || 0\n    };\n  } else { // else project\n    point = dest.forward(point);\n    if (dest.to_meter) {\n      point = {\n        x: point.x / dest.to_meter,\n        y: point.y / dest.to_meter,\n        z: point.z || 0\n      };\n    }\n  }\n\n  // DGR, 2010/11/12\n  if (dest.axis !== 'enu') {\n    return adjust_axis(dest, true, point);\n  }\n\n  return point;\n}\n","import proj from './Proj';\nimport transform from './transform';\nvar wgs84 = proj('WGS84');\n\nfunction transformer(from, to, coords) {\n  var transformedArray, out, keys;\n  if (Array.isArray(coords)) {\n    transformedArray = transform(from, to, coords) || {x: NaN, y: NaN};\n    if (coords.length > 2) {\n      if ((typeof from.name !== 'undefined' && from.name === 'geocent') || (typeof to.name !== 'undefined' && to.name === 'geocent')) {\n        if (typeof transformedArray.z === 'number') {\n          return [transformedArray.x, transformedArray.y, transformedArray.z].concat(coords.splice(3));\n        } else {\n          return [transformedArray.x, transformedArray.y, coords[2]].concat(coords.splice(3));\n        }\n      } else {\n        return [transformedArray.x, transformedArray.y].concat(coords.splice(2));\n      }\n    } else {\n      return [transformedArray.x, transformedArray.y];\n    }\n  } else {\n    out = transform(from, to, coords);\n    keys = Object.keys(coords);\n    if (keys.length === 2) {\n      return out;\n    }\n    keys.forEach(function (key) {\n      if ((typeof from.name !== 'undefined' && from.name === 'geocent') || (typeof to.name !== 'undefined' && to.name === 'geocent')) {\n        if (key === 'x' || key === 'y' || key === 'z') {\n          return;\n        }\n      } else {\n        if (key === 'x' || key === 'y') {\n          return;\n        }\n      }\n      out[key] = coords[key];\n    });\n    return out;\n  }\n}\n\nfunction checkProj(item) {\n  if (item instanceof proj) {\n    return item;\n  }\n  if (item.oProj) {\n    return item.oProj;\n  }\n  return proj(item);\n}\n\nfunction proj4(fromProj, toProj, coord) {\n  fromProj = checkProj(fromProj);\n  var single = false;\n  var obj;\n  if (typeof toProj === 'undefined') {\n    toProj = fromProj;\n    fromProj = wgs84;\n    single = true;\n  } else if (typeof toProj.x !== 'undefined' || Array.isArray(toProj)) {\n    coord = toProj;\n    toProj = fromProj;\n    fromProj = wgs84;\n    single = true;\n  }\n  toProj = checkProj(toProj);\n  if (coord) {\n    return transformer(fromProj, toProj, coord);\n  } else {\n    obj = {\n      forward: function (coords) {\n        return transformer(fromProj, toProj, coords);\n      },\n      inverse: function (coords) {\n        return transformer(toProj, fromProj, coords);\n      }\n    };\n    if (single) {\n      obj.oProj = toProj;\n    }\n    return obj;\n  }\n}\nexport default proj4;","\n\n\n/**\n * UTM zones are grouped, and assigned to one of a group of 6\n * sets.\n *\n * {int} @private\n */\nvar NUM_100K_SETS = 6;\n\n/**\n * The column letters (for easting) of the lower left value, per\n * set.\n *\n * {string} @private\n */\nvar SET_ORIGIN_COLUMN_LETTERS = 'AJSAJS';\n\n/**\n * The row letters (for northing) of the lower left value, per\n * set.\n *\n * {string} @private\n */\nvar SET_ORIGIN_ROW_LETTERS = 'AFAFAF';\n\nvar A = 65; // A\nvar I = 73; // I\nvar O = 79; // O\nvar V = 86; // V\nvar Z = 90; // Z\nexport default {\n  forward: forward,\n  inverse: inverse,\n  toPoint: toPoint\n};\n/**\n * Conversion of lat/lon to MGRS.\n *\n * @param {object} ll Object literal with lat and lon properties on a\n *     WGS84 ellipsoid.\n * @param {int} accuracy Accuracy in digits (5 for 1 m, 4 for 10 m, 3 for\n *      100 m, 2 for 1000 m or 1 for 10000 m). Optional, default is 5.\n * @return {string} the MGRS string for the given location and accuracy.\n */\nexport function forward(ll, accuracy) {\n  accuracy = accuracy || 5; // default accuracy 1m\n  return encode(LLtoUTM({\n    lat: ll[1],\n    lon: ll[0]\n  }), accuracy);\n};\n\n/**\n * Conversion of MGRS to lat/lon.\n *\n * @param {string} mgrs MGRS string.\n * @return {array} An array with left (longitude), bottom (latitude), right\n *     (longitude) and top (latitude) values in WGS84, representing the\n *     bounding box for the provided MGRS reference.\n */\nexport function inverse(mgrs) {\n  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));\n  if (bbox.lat && bbox.lon) {\n    return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];\n  }\n  return [bbox.left, bbox.bottom, bbox.right, bbox.top];\n};\n\nexport function toPoint(mgrs) {\n  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));\n  if (bbox.lat && bbox.lon) {\n    return [bbox.lon, bbox.lat];\n  }\n  return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];\n};\n/**\n * Conversion from degrees to radians.\n *\n * @private\n * @param {number} deg the angle in degrees.\n * @return {number} the angle in radians.\n */\nfunction degToRad(deg) {\n  return (deg * (Math.PI / 180.0));\n}\n\n/**\n * Conversion from radians to degrees.\n *\n * @private\n * @param {number} rad the angle in radians.\n * @return {number} the angle in degrees.\n */\nfunction radToDeg(rad) {\n  return (180.0 * (rad / Math.PI));\n}\n\n/**\n * Converts a set of Longitude and Latitude co-ordinates to UTM\n * using the WGS84 ellipsoid.\n *\n * @private\n * @param {object} ll Object literal with lat and lon properties\n *     representing the WGS84 coordinate to be converted.\n * @return {object} Object literal containing the UTM value with easting,\n *     northing, zoneNumber and zoneLetter properties, and an optional\n *     accuracy property in digits. Returns null if the conversion failed.\n */\nfunction LLtoUTM(ll) {\n  var Lat = ll.lat;\n  var Long = ll.lon;\n  var a = 6378137.0; //ellip.radius;\n  var eccSquared = 0.00669438; //ellip.eccsq;\n  var k0 = 0.9996;\n  var LongOrigin;\n  var eccPrimeSquared;\n  var N, T, C, A, M;\n  var LatRad = degToRad(Lat);\n  var LongRad = degToRad(Long);\n  var LongOriginRad;\n  var ZoneNumber;\n  // (int)\n  ZoneNumber = Math.floor((Long + 180) / 6) + 1;\n\n  //Make sure the longitude 180.00 is in Zone 60\n  if (Long === 180) {\n    ZoneNumber = 60;\n  }\n\n  // Special zone for Norway\n  if (Lat >= 56.0 && Lat < 64.0 && Long >= 3.0 && Long < 12.0) {\n    ZoneNumber = 32;\n  }\n\n  // Special zones for Svalbard\n  if (Lat >= 72.0 && Lat < 84.0) {\n    if (Long >= 0.0 && Long < 9.0) {\n      ZoneNumber = 31;\n    }\n    else if (Long >= 9.0 && Long < 21.0) {\n      ZoneNumber = 33;\n    }\n    else if (Long >= 21.0 && Long < 33.0) {\n      ZoneNumber = 35;\n    }\n    else if (Long >= 33.0 && Long < 42.0) {\n      ZoneNumber = 37;\n    }\n  }\n\n  LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3; //+3 puts origin\n  // in middle of\n  // zone\n  LongOriginRad = degToRad(LongOrigin);\n\n  eccPrimeSquared = (eccSquared) / (1 - eccSquared);\n\n  N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));\n  T = Math.tan(LatRad) * Math.tan(LatRad);\n  C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);\n  A = Math.cos(LatRad) * (LongRad - LongOriginRad);\n\n  M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - (35 * eccSquared * eccSquared * eccSquared / 3072) * Math.sin(6 * LatRad));\n\n  var UTMEasting = (k0 * N * (A + (1 - T + C) * A * A * A / 6.0 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120.0) + 500000.0);\n\n  var UTMNorthing = (k0 * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24.0 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720.0)));\n  if (Lat < 0.0) {\n    UTMNorthing += 10000000.0; //10000000 meter offset for\n    // southern hemisphere\n  }\n\n  return {\n    northing: Math.round(UTMNorthing),\n    easting: Math.round(UTMEasting),\n    zoneNumber: ZoneNumber,\n    zoneLetter: getLetterDesignator(Lat)\n  };\n}\n\n/**\n * Converts UTM coords to lat/long, using the WGS84 ellipsoid. This is a convenience\n * class where the Zone can be specified as a single string eg.\"60N\" which\n * is then broken down into the ZoneNumber and ZoneLetter.\n *\n * @private\n * @param {object} utm An object literal with northing, easting, zoneNumber\n *     and zoneLetter properties. If an optional accuracy property is\n *     provided (in meters), a bounding box will be returned instead of\n *     latitude and longitude.\n * @return {object} An object literal containing either lat and lon values\n *     (if no accuracy was provided), or top, right, bottom and left values\n *     for the bounding box calculated according to the provided accuracy.\n *     Returns null if the conversion failed.\n */\nfunction UTMtoLL(utm) {\n\n  var UTMNorthing = utm.northing;\n  var UTMEasting = utm.easting;\n  var zoneLetter = utm.zoneLetter;\n  var zoneNumber = utm.zoneNumber;\n  // check the ZoneNummber is valid\n  if (zoneNumber < 0 || zoneNumber > 60) {\n    return null;\n  }\n\n  var k0 = 0.9996;\n  var a = 6378137.0; //ellip.radius;\n  var eccSquared = 0.00669438; //ellip.eccsq;\n  var eccPrimeSquared;\n  var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));\n  var N1, T1, C1, R1, D, M;\n  var LongOrigin;\n  var mu, phi1Rad;\n\n  // remove 500,000 meter offset for longitude\n  var x = UTMEasting - 500000.0;\n  var y = UTMNorthing;\n\n  // We must know somehow if we are in the Northern or Southern\n  // hemisphere, this is the only time we use the letter So even\n  // if the Zone letter isn't exactly correct it should indicate\n  // the hemisphere correctly\n  if (zoneLetter < 'N') {\n    y -= 10000000.0; // remove 10,000,000 meter offset used\n    // for southern hemisphere\n  }\n\n  // There are 60 zones with zone 1 being at West -180 to -174\n  LongOrigin = (zoneNumber - 1) * 6 - 180 + 3; // +3 puts origin\n  // in middle of\n  // zone\n\n  eccPrimeSquared = (eccSquared) / (1 - eccSquared);\n\n  M = y / k0;\n  mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));\n\n  phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + (151 * e1 * e1 * e1 / 96) * Math.sin(6 * mu);\n  // double phi1 = ProjMath.radToDeg(phi1Rad);\n\n  N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));\n  T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);\n  C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);\n  R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);\n  D = x / (N1 * k0);\n\n  var lat = phi1Rad - (N1 * Math.tan(phi1Rad) / R1) * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1) * D * D * D * D * D * D / 720);\n  lat = radToDeg(lat);\n\n  var lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);\n  lon = LongOrigin + radToDeg(lon);\n\n  var result;\n  if (utm.accuracy) {\n    var topRight = UTMtoLL({\n      northing: utm.northing + utm.accuracy,\n      easting: utm.easting + utm.accuracy,\n      zoneLetter: utm.zoneLetter,\n      zoneNumber: utm.zoneNumber\n    });\n    result = {\n      top: topRight.lat,\n      right: topRight.lon,\n      bottom: lat,\n      left: lon\n    };\n  }\n  else {\n    result = {\n      lat: lat,\n      lon: lon\n    };\n  }\n  return result;\n}\n\n/**\n * Calculates the MGRS letter designator for the given latitude.\n *\n * @private\n * @param {number} lat The latitude in WGS84 to get the letter designator\n *     for.\n * @return {char} The letter designator.\n */\nfunction getLetterDesignator(lat) {\n  //This is here as an error flag to show that the Latitude is\n  //outside MGRS limits\n  var LetterDesignator = 'Z';\n\n  if ((84 >= lat) && (lat >= 72)) {\n    LetterDesignator = 'X';\n  }\n  else if ((72 > lat) && (lat >= 64)) {\n    LetterDesignator = 'W';\n  }\n  else if ((64 > lat) && (lat >= 56)) {\n    LetterDesignator = 'V';\n  }\n  else if ((56 > lat) && (lat >= 48)) {\n    LetterDesignator = 'U';\n  }\n  else if ((48 > lat) && (lat >= 40)) {\n    LetterDesignator = 'T';\n  }\n  else if ((40 > lat) && (lat >= 32)) {\n    LetterDesignator = 'S';\n  }\n  else if ((32 > lat) && (lat >= 24)) {\n    LetterDesignator = 'R';\n  }\n  else if ((24 > lat) && (lat >= 16)) {\n    LetterDesignator = 'Q';\n  }\n  else if ((16 > lat) && (lat >= 8)) {\n    LetterDesignator = 'P';\n  }\n  else if ((8 > lat) && (lat >= 0)) {\n    LetterDesignator = 'N';\n  }\n  else if ((0 > lat) && (lat >= -8)) {\n    LetterDesignator = 'M';\n  }\n  else if ((-8 > lat) && (lat >= -16)) {\n    LetterDesignator = 'L';\n  }\n  else if ((-16 > lat) && (lat >= -24)) {\n    LetterDesignator = 'K';\n  }\n  else if ((-24 > lat) && (lat >= -32)) {\n    LetterDesignator = 'J';\n  }\n  else if ((-32 > lat) && (lat >= -40)) {\n    LetterDesignator = 'H';\n  }\n  else if ((-40 > lat) && (lat >= -48)) {\n    LetterDesignator = 'G';\n  }\n  else if ((-48 > lat) && (lat >= -56)) {\n    LetterDesignator = 'F';\n  }\n  else if ((-56 > lat) && (lat >= -64)) {\n    LetterDesignator = 'E';\n  }\n  else if ((-64 > lat) && (lat >= -72)) {\n    LetterDesignator = 'D';\n  }\n  else if ((-72 > lat) && (lat >= -80)) {\n    LetterDesignator = 'C';\n  }\n  return LetterDesignator;\n}\n\n/**\n * Encodes a UTM location as MGRS string.\n *\n * @private\n * @param {object} utm An object literal with easting, northing,\n *     zoneLetter, zoneNumber\n * @param {number} accuracy Accuracy in digits (1-5).\n * @return {string} MGRS string for the given UTM location.\n */\nfunction encode(utm, accuracy) {\n  // prepend with leading zeroes\n  var seasting = \"00000\" + utm.easting,\n    snorthing = \"00000\" + utm.northing;\n\n  return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);\n}\n\n/**\n * Get the two letter 100k designator for a given UTM easting,\n * northing and zone number value.\n *\n * @private\n * @param {number} easting\n * @param {number} northing\n * @param {number} zoneNumber\n * @return the two letter 100k designator for the given UTM location.\n */\nfunction get100kID(easting, northing, zoneNumber) {\n  var setParm = get100kSetForZone(zoneNumber);\n  var setColumn = Math.floor(easting / 100000);\n  var setRow = Math.floor(northing / 100000) % 20;\n  return getLetter100kID(setColumn, setRow, setParm);\n}\n\n/**\n * Given a UTM zone number, figure out the MGRS 100K set it is in.\n *\n * @private\n * @param {number} i An UTM zone number.\n * @return {number} the 100k set the UTM zone is in.\n */\nfunction get100kSetForZone(i) {\n  var setParm = i % NUM_100K_SETS;\n  if (setParm === 0) {\n    setParm = NUM_100K_SETS;\n  }\n\n  return setParm;\n}\n\n/**\n * Get the two-letter MGRS 100k designator given information\n * translated from the UTM northing, easting and zone number.\n *\n * @private\n * @param {number} column the column index as it relates to the MGRS\n *        100k set spreadsheet, created from the UTM easting.\n *        Values are 1-8.\n * @param {number} row the row index as it relates to the MGRS 100k set\n *        spreadsheet, created from the UTM northing value. Values\n *        are from 0-19.\n * @param {number} parm the set block, as it relates to the MGRS 100k set\n *        spreadsheet, created from the UTM zone. Values are from\n *        1-60.\n * @return two letter MGRS 100k code.\n */\nfunction getLetter100kID(column, row, parm) {\n  // colOrigin and rowOrigin are the letters at the origin of the set\n  var index = parm - 1;\n  var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);\n  var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);\n\n  // colInt and rowInt are the letters to build to return\n  var colInt = colOrigin + column - 1;\n  var rowInt = rowOrigin + row;\n  var rollover = false;\n\n  if (colInt > Z) {\n    colInt = colInt - Z + A - 1;\n    rollover = true;\n  }\n\n  if (colInt === I || (colOrigin < I && colInt > I) || ((colInt > I || colOrigin < I) && rollover)) {\n    colInt++;\n  }\n\n  if (colInt === O || (colOrigin < O && colInt > O) || ((colInt > O || colOrigin < O) && rollover)) {\n    colInt++;\n\n    if (colInt === I) {\n      colInt++;\n    }\n  }\n\n  if (colInt > Z) {\n    colInt = colInt - Z + A - 1;\n  }\n\n  if (rowInt > V) {\n    rowInt = rowInt - V + A - 1;\n    rollover = true;\n  }\n  else {\n    rollover = false;\n  }\n\n  if (((rowInt === I) || ((rowOrigin < I) && (rowInt > I))) || (((rowInt > I) || (rowOrigin < I)) && rollover)) {\n    rowInt++;\n  }\n\n  if (((rowInt === O) || ((rowOrigin < O) && (rowInt > O))) || (((rowInt > O) || (rowOrigin < O)) && rollover)) {\n    rowInt++;\n\n    if (rowInt === I) {\n      rowInt++;\n    }\n  }\n\n  if (rowInt > V) {\n    rowInt = rowInt - V + A - 1;\n  }\n\n  var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);\n  return twoLetter;\n}\n\n/**\n * Decode the UTM parameters from a MGRS string.\n *\n * @private\n * @param {string} mgrsString an UPPERCASE coordinate string is expected.\n * @return {object} An object literal with easting, northing, zoneLetter,\n *     zoneNumber and accuracy (in meters) properties.\n */\nfunction decode(mgrsString) {\n\n  if (mgrsString && mgrsString.length === 0) {\n    throw (\"MGRSPoint coverting from nothing\");\n  }\n\n  var length = mgrsString.length;\n\n  var hunK = null;\n  var sb = \"\";\n  var testChar;\n  var i = 0;\n\n  // get Zone number\n  while (!(/[A-Z]/).test(testChar = mgrsString.charAt(i))) {\n    if (i >= 2) {\n      throw (\"MGRSPoint bad conversion from: \" + mgrsString);\n    }\n    sb += testChar;\n    i++;\n  }\n\n  var zoneNumber = parseInt(sb, 10);\n\n  if (i === 0 || i + 3 > length) {\n    // A good MGRS string has to be 4-5 digits long,\n    // ##AAA/#AAA at least.\n    throw (\"MGRSPoint bad conversion from: \" + mgrsString);\n  }\n\n  var zoneLetter = mgrsString.charAt(i++);\n\n  // Should we check the zone letter here? Why not.\n  if (zoneLetter <= 'A' || zoneLetter === 'B' || zoneLetter === 'Y' || zoneLetter >= 'Z' || zoneLetter === 'I' || zoneLetter === 'O') {\n    throw (\"MGRSPoint zone letter \" + zoneLetter + \" not handled: \" + mgrsString);\n  }\n\n  hunK = mgrsString.substring(i, i += 2);\n\n  var set = get100kSetForZone(zoneNumber);\n\n  var east100k = getEastingFromChar(hunK.charAt(0), set);\n  var north100k = getNorthingFromChar(hunK.charAt(1), set);\n\n  // We have a bug where the northing may be 2000000 too low.\n  // How\n  // do we know when to roll over?\n\n  while (north100k < getMinNorthing(zoneLetter)) {\n    north100k += 2000000;\n  }\n\n  // calculate the char index for easting/northing separator\n  var remainder = length - i;\n\n  if (remainder % 2 !== 0) {\n    throw (\"MGRSPoint has to have an even number \\nof digits after the zone letter and two 100km letters - front \\nhalf for easting meters, second half for \\nnorthing meters\" + mgrsString);\n  }\n\n  var sep = remainder / 2;\n\n  var sepEasting = 0.0;\n  var sepNorthing = 0.0;\n  var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;\n  if (sep > 0) {\n    accuracyBonus = 100000.0 / Math.pow(10, sep);\n    sepEastingString = mgrsString.substring(i, i + sep);\n    sepEasting = parseFloat(sepEastingString) * accuracyBonus;\n    sepNorthingString = mgrsString.substring(i + sep);\n    sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;\n  }\n\n  easting = sepEasting + east100k;\n  northing = sepNorthing + north100k;\n\n  return {\n    easting: easting,\n    northing: northing,\n    zoneLetter: zoneLetter,\n    zoneNumber: zoneNumber,\n    accuracy: accuracyBonus\n  };\n}\n\n/**\n * Given the first letter from a two-letter MGRS 100k zone, and given the\n * MGRS table set for the zone number, figure out the easting value that\n * should be added to the other, secondary easting value.\n *\n * @private\n * @param {char} e The first letter from a two-letter MGRS 100´k zone.\n * @param {number} set The MGRS table set for the zone number.\n * @return {number} The easting value for the given letter and set.\n */\nfunction getEastingFromChar(e, set) {\n  // colOrigin is the letter at the origin of the set for the\n  // column\n  var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);\n  var eastingValue = 100000.0;\n  var rewindMarker = false;\n\n  while (curCol !== e.charCodeAt(0)) {\n    curCol++;\n    if (curCol === I) {\n      curCol++;\n    }\n    if (curCol === O) {\n      curCol++;\n    }\n    if (curCol > Z) {\n      if (rewindMarker) {\n        throw (\"Bad character: \" + e);\n      }\n      curCol = A;\n      rewindMarker = true;\n    }\n    eastingValue += 100000.0;\n  }\n\n  return eastingValue;\n}\n\n/**\n * Given the second letter from a two-letter MGRS 100k zone, and given the\n * MGRS table set for the zone number, figure out the northing value that\n * should be added to the other, secondary northing value. You have to\n * remember that Northings are determined from the equator, and the vertical\n * cycle of letters mean a 2000000 additional northing meters. This happens\n * approx. every 18 degrees of latitude. This method does *NOT* count any\n * additional northings. You have to figure out how many 2000000 meters need\n * to be added for the zone letter of the MGRS coordinate.\n *\n * @private\n * @param {char} n Second letter of the MGRS 100k zone\n * @param {number} set The MGRS table set number, which is dependent on the\n *     UTM zone number.\n * @return {number} The northing value for the given letter and set.\n */\nfunction getNorthingFromChar(n, set) {\n\n  if (n > 'V') {\n    throw (\"MGRSPoint given invalid Northing \" + n);\n  }\n\n  // rowOrigin is the letter at the origin of the set for the\n  // column\n  var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);\n  var northingValue = 0.0;\n  var rewindMarker = false;\n\n  while (curRow !== n.charCodeAt(0)) {\n    curRow++;\n    if (curRow === I) {\n      curRow++;\n    }\n    if (curRow === O) {\n      curRow++;\n    }\n    // fixing a bug making whole application hang in this loop\n    // when 'n' is a wrong character\n    if (curRow > V) {\n      if (rewindMarker) { // making sure that this loop ends\n        throw (\"Bad character: \" + n);\n      }\n      curRow = A;\n      rewindMarker = true;\n    }\n    northingValue += 100000.0;\n  }\n\n  return northingValue;\n}\n\n/**\n * The function getMinNorthing returns the minimum northing value of a MGRS\n * zone.\n *\n * Ported from Geotrans' c Lattitude_Band_Value structure table.\n *\n * @private\n * @param {char} zoneLetter The MGRS zone to get the min northing for.\n * @return {number}\n */\nfunction getMinNorthing(zoneLetter) {\n  var northing;\n  switch (zoneLetter) {\n  case 'C':\n    northing = 1100000.0;\n    break;\n  case 'D':\n    northing = 2000000.0;\n    break;\n  case 'E':\n    northing = 2800000.0;\n    break;\n  case 'F':\n    northing = 3700000.0;\n    break;\n  case 'G':\n    northing = 4600000.0;\n    break;\n  case 'H':\n    northing = 5500000.0;\n    break;\n  case 'J':\n    northing = 6400000.0;\n    break;\n  case 'K':\n    northing = 7300000.0;\n    break;\n  case 'L':\n    northing = 8200000.0;\n    break;\n  case 'M':\n    northing = 9100000.0;\n    break;\n  case 'N':\n    northing = 0.0;\n    break;\n  case 'P':\n    northing = 800000.0;\n    break;\n  case 'Q':\n    northing = 1700000.0;\n    break;\n  case 'R':\n    northing = 2600000.0;\n    break;\n  case 'S':\n    northing = 3500000.0;\n    break;\n  case 'T':\n    northing = 4400000.0;\n    break;\n  case 'U':\n    northing = 5300000.0;\n    break;\n  case 'V':\n    northing = 6200000.0;\n    break;\n  case 'W':\n    northing = 7000000.0;\n    break;\n  case 'X':\n    northing = 7900000.0;\n    break;\n  default:\n    northing = -1.0;\n  }\n  if (northing >= 0.0) {\n    return northing;\n  }\n  else {\n    throw (\"Invalid zone letter: \" + zoneLetter);\n  }\n\n}\n","import {toPoint, forward} from 'mgrs';\n\nfunction Point(x, y, z) {\n  if (!(this instanceof Point)) {\n    return new Point(x, y, z);\n  }\n  if (Array.isArray(x)) {\n    this.x = x[0];\n    this.y = x[1];\n    this.z = x[2] || 0.0;\n  } else if(typeof x === 'object') {\n    this.x = x.x;\n    this.y = x.y;\n    this.z = x.z || 0.0;\n  } else if (typeof x === 'string' && typeof y === 'undefined') {\n    var coords = x.split(',');\n    this.x = parseFloat(coords[0], 10);\n    this.y = parseFloat(coords[1], 10);\n    this.z = parseFloat(coords[2], 10) || 0.0;\n  } else {\n    this.x = x;\n    this.y = y;\n    this.z = z || 0.0;\n  }\n  console.warn('proj4.Point will be removed in version 3, use proj4.toPoint');\n}\n\nPoint.fromMGRS = function(mgrsStr) {\n  return new Point(toPoint(mgrsStr));\n};\nPoint.prototype.toMGRS = function(accuracy) {\n  return forward([this.x, this.y], accuracy);\n};\nexport default Point;\n","import proj4 from './core';\nimport Proj from \"./Proj\";\nimport Point from \"./Point\";\nimport common from \"./common/toPoint\";\nimport defs from \"./defs\";\nimport transform from \"./transform\";\nimport mgrs from \"mgrs\";\nimport includedProjections from \"../projs\";\n\nproj4.defaultDatum = 'WGS84'; //default datum\nproj4.Proj = Proj;\nproj4.WGS84 = new proj4.Proj('WGS84');\nproj4.Point = Point;\nproj4.toPoint = common;\nproj4.defs = defs;\nproj4.transform = transform;\nproj4.mgrs = mgrs;\nproj4.version = '__VERSION__';\nincludedProjections(proj4);\nexport default proj4;\n"],"names":["SEC_TO_RAD","HALF_PI","Math","PI","EPSLN","D2R","R2D","FORTPI","TWO_PI","exports","greenwich","lisbon","paris","bogota","madrid","rome","bern","jakarta","ferro","brussels","stockholm","athens","oslo","ft","to_meter","us-ft","ignoredChar","match","obj","key","testkey","keys","Object","lkey","toLowerCase","replace","i","length","defData","paramName","paramVal","paramOutname","self","paramObj","split","map","v","trim","filter","a","reduce","p","push","params","proj","datum","rf","parseFloat","lat_0","lat0","lat_1","lat1","lat_2","lat2","lat_ts","lon_0","long0","lon_1","long1","lon_2","long2","alpha","lonc","longc","x_0","x0","y_0","y0","k_0","k0","k","b","r_a","R_A","zone","parseInt","south","utmSouth","towgs84","datum_params","units","unit","from_greenwich","pm","PrimeMeridian","nadgrids","datumCode","axis","indexOf","substr","whitespace","latin","keyword","endThings","digets","Parser","text","Error","this","level","place","root","stack","currentObject","state","mapit","value","Array","isArray","unshift","thing","out","newObj","item","sExpr","shift","name","convert","prototype","readCharicter","char","test","neutral","quoted","afterquote","number","word","afterItem","pop","newObjects","output","d2r","input","wkt","lisp","type","projName","local","PROJECTION","AXIS","axisOrder","ii","descriptor","UNIT","DATUM","SPHEROID","geogcs","GEOGCS","toMeter","slice","sphere","ellps","TOWGS84","isFinite","forEach","outName","inName","cleanWKT","defs","that","arguments","def","charAt","parseProj","apply","EPSG","ESRI","IAU2000","console","log","WGS84","GOOGLE","globals","codeWords","codes","parse","code","testObj","testDef","some","testWKT","auth","checkMercator","maybeProjStr","ext","checkProjStr","projStr","testProj","destination","source","property","undefined","eccent","sinphi","cosphi","con","sqrt","x","abs","sign","phi","com","pow","tan","ts","dphi","eccnth","atan","sin","identity","pt","projs","init","es","e","cos","msfnz","forward","y","lon","lat","adjust_lon","tsfnz","inverse","exp","phi2z","names","projStore","add","len","n","start","get","ellipseName","Projection","srsCode","callback","error","json","parseCode","ourProj","projections","datumDef","Datum","ellipse","datumName","a2","b2","sphere_","Ellipsoid","dc_sphere","ecc","ep2","datumObj","datum_type","extend","checkParams","dest","point","compareDatums","Rn","Sin_Lat","Sin2_Lat","Cos_Lat","Longitude","Latitude","Height","z","Infinity","geodeticToGeocentric","Dx_BF","Dy_BF","Dz_BF","Rx_BF","Ry_BF","Rz_BF","M_BF","geocentricToWgs84","x_tmp","y_tmp","z_tmp","geocentricFromWgs84","P","RR","CT","ST","RX","RK","RN","CPHI0","SPHI0","CPHI","SPHI","SDPHI","iter","X","Y","Z","atan2","geocentricToGeodetic","crs","denorm","t","xin","yin","zin","array","m","checkCoord","num","Number","TypeError","transform","wgs84","toPoint","checkSanity","checkNotWGS","adjust_axis","datum_transform","ch1903","ggrs87","nad83","nad27","potsdam","carthage","hermannskogel","osni52","ire65","rassadiran","nzgd49","osgb36","s_jtsk","beduaram","gunung_segara","rnb72","transformer","from","to","coords","transformedArray","NaN","concat","splice","checkProj","oProj","proj4","fromProj","toProj","coord","single","A","I","O","mgrs","bbox","UTMtoLL","decode","toUpperCase","left","bottom","right","top","ll","accuracy","utm","seasting","easting","snorthing","northing","zoneNumber","zoneLetter","setParm","get100kSetForZone","setColumn","floor","setRow","column","row","parm","index","colOrigin","charCodeAt","rowOrigin","colInt","rowInt","rollover","String","fromCharCode","encode","N","T","C","M","LongOriginRad","ZoneNumber","Lat","Long","LatRad","degToRad","LongRad","UTMEasting","UTMNorthing","round","getLetterDesignator","LLtoUTM","deg","radToDeg","rad","N1","T1","C1","R1","D","LongOrigin","mu","phi1Rad","e1","result","topRight","LetterDesignator","mgrsString","testChar","hunK","sb","substring","set","east100k","curCol","eastingValue","rewindMarker","getEastingFromChar","north100k","curRow","northingValue","getNorthingFromChar","getMinNorthing","remainder","accuracyBonus","sepEastingString","sepNorthingString","sep","sepEasting","sepNorthing","Point","warn","fromMGRS","mgrsStr","toMGRS","defaultDatum","Proj","common","version"],"mappings":"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"}